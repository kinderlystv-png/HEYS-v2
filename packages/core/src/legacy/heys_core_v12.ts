/*
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üó∫Ô∏è –ù–ê–í–ò–ì–ê–¶–ò–û–ù–ù–ê–Ø –ö–ê–†–¢–ê –§–ê–ô–õ–ê heys_core_v12.ts (523 —Å—Ç—Ä–æ–∫–∏)                              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ üìã –°–¢–†–£–ö–¢–£–†–ê –§–ê–ô–õ–ê:                                                                       ‚îÇ
‚îÇ                                                                                           ‚îÇ
‚îÇ üìò –¢–ò–ü–´ –ò –ò–ù–¢–ï–†–§–ï–ô–°–´ (—Å—Ç—Ä–æ–∫–∏ 1-100):                                                     ‚îÇ
‚îÇ    ‚îú‚îÄ‚îÄ –ò–º–ø–æ—Ä—Ç—ã –∏ —Ç–∏–ø—ã (3-4)                                                             ‚îÇ
‚îÇ    ‚îú‚îÄ‚îÄ Global interface (6-12)                                                          ‚îÇ
‚îÇ    ‚îú‚îÄ‚îÄ CoreUtils interface (14-22)                                                      ‚îÇ
‚îÇ    ‚îú‚îÄ‚îÄ ParsedRow interface (24-29)                                                      ‚îÇ
‚îÇ    ‚îú‚îÄ‚îÄ ProductDraft interface (31-42)                                                   ‚îÇ
‚îÇ    ‚îî‚îÄ‚îÄ Props interfaces (44-48)                                                         ‚îÇ
‚îÇ                                                                                           ‚îÇ
‚îÇ üõ†Ô∏è –û–°–ù–û–í–ù–´–ï –£–¢–ò–õ–ò–¢–´ (—Å—Ç—Ä–æ–∫–∏ 101-200):                                                   ‚îÇ
‚îÇ    ‚îú‚îÄ‚îÄ –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∏ —Ä–µ–≥—É–ª—è—Ä–Ω—ã–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è (49-52)                                         ‚îÇ
‚îÇ    ‚îú‚îÄ‚îÄ –ë–∞–∑–æ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏: round1, uuid, toNum (53-58)                                     ‚îÇ
‚îÇ    ‚îú‚îÄ‚îÄ computeDerived() - –ø—Ä–æ–∏–∑–≤–æ–¥–Ω—ã–µ —Ä–∞—Å—á–µ—Ç—ã (59-70)                                   ‚îÇ
‚îÇ    ‚îú‚îÄ‚îÄ lsGet, lsSet - localStorage (71-85)                                              ‚îÇ
‚îÇ    ‚îî‚îÄ‚îÄ –¢–µ–∫—Å—Ç–æ–≤—ã–µ —É—Ç–∏–ª–∏—Ç—ã (86-95)                                                        ‚îÇ
‚îÇ                                                                                           ‚îÇ
‚îÇ üìÑ –ü–ê–†–°–ò–ù–ì –î–ê–ù–ù–´–• (—Å—Ç—Ä–æ–∫–∏ 201-350):                                                      ‚îÇ
‚îÇ    ‚îú‚îÄ‚îÄ isHeaderLine() - –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ (96-100)                                 ‚îÇ
‚îÇ    ‚îú‚îÄ‚îÄ normalizeLine() - –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç—Ä–æ–∫ (101-110)                                   ‚îÇ
‚îÇ    ‚îú‚îÄ‚îÄ findTokenPositions() - –ø–æ–∏—Å–∫ –ø–æ–∑–∏—Ü–∏–π (111-120)                                   ‚îÇ
‚îÇ    ‚îú‚îÄ‚îÄ extractRow() - –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ (121-140)                                       ‚îÇ
‚îÇ    ‚îú‚îÄ‚îÄ Web Worker –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è (141-180)                                                  ‚îÇ
‚îÇ    ‚îî‚îÄ‚îÄ parsePastedSync() - —Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥ (181-200)                                 ‚îÇ
‚îÇ                                                                                           ‚îÇ
‚îÇ üìä –£–ü–†–ê–í–õ–ï–ù–ò–ï –ü–†–û–î–£–ö–¢–ê–ú–ò (—Å—Ç—Ä–æ–∫–∏ 351-450):                                               ‚îÇ
‚îÇ    ‚îú‚îÄ‚îÄ getAllProducts() - –ø–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ (201-220)                                    ‚îÇ
‚îÇ    ‚îú‚îÄ‚îÄ addProduct() - –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–¥—É–∫—Ç–∞ (221-250)                                     ‚îÇ
‚îÇ    ‚îú‚îÄ‚îÄ saveProduct() - —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π (251-280)                                   ‚îÇ
‚îÇ    ‚îú‚îÄ‚îÄ deleteProduct() - —É–¥–∞–ª–µ–Ω–∏–µ (281-300)                                             ‚îÇ
‚îÇ    ‚îî‚îÄ‚îÄ searchProducts() - –ø–æ–∏—Å–∫ –∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è (301-320)                                  ‚îÇ
‚îÇ                                                                                           ‚îÇ
‚îÇ ‚öõÔ∏è REACT –ö–û–ú–ü–û–ù–ï–ù–¢ RationTab (—Å—Ç—Ä–æ–∫–∏ 451-523):                                           ‚îÇ
‚îÇ    ‚îú‚îÄ‚îÄ –ö–ª–∞—Å—Å –∏ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä (321-340)                                                    ‚îÇ
‚îÇ    ‚îú‚îÄ‚îÄ State management —Å —Ç–∏–ø–∞–º–∏ (341-360)                                              ‚îÇ
‚îÇ    ‚îú‚îÄ‚îÄ Event handlers —Å —Ç–∏–ø–∏–∑–∞—Ü–∏–µ–π (361-420):                                           ‚îÇ
‚îÇ    ‚îÇ   ‚îú‚îÄ‚îÄ handleAddProduct() (361-380)                                                 ‚îÇ
‚îÇ    ‚îÇ   ‚îú‚îÄ‚îÄ handleEditProduct() (381-400)                                                ‚îÇ
‚îÇ    ‚îÇ   ‚îú‚îÄ‚îÄ handleDeleteProduct() (401-410)                                              ‚îÇ
‚îÇ    ‚îÇ   ‚îî‚îÄ‚îÄ handlePasteData() (411-420)                                                  ‚îÇ
‚îÇ    ‚îú‚îÄ‚îÄ Render –º–µ—Ç–æ–¥—ã (421-480):                                                          ‚îÇ
‚îÇ    ‚îÇ   ‚îú‚îÄ‚îÄ renderProductForm() (421-450)                                                ‚îÇ
‚îÇ    ‚îÇ   ‚îú‚îÄ‚îÄ renderProductList() (451-470)                                                ‚îÇ
‚îÇ    ‚îÇ   ‚îî‚îÄ‚îÄ renderPasteArea() (471-480)                                                  ‚îÇ
‚îÇ    ‚îî‚îÄ‚îÄ Main render() method (481-500)                                                    ‚îÇ
‚îÇ                                                                                           ‚îÇ
‚îÇ üîó –≠–ö–°–ü–û–†–¢ –ò –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø (—Å—Ç—Ä–æ–∫–∏ 501-523):                                             ‚îÇ
‚îÇ    ‚îú‚îÄ‚îÄ TypeScript —ç–∫—Å–ø–æ—Ä—Ç—ã (501-515)                                                    ‚îÇ
‚îÇ    ‚îú‚îÄ‚îÄ HEYS namespace —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ (516-520)                                              ‚îÇ
‚îÇ    ‚îî‚îÄ‚îÄ –£—Ç–∏–ª–∏—Ç—ã —ç–∫—Å–ø–æ—Ä—Ç (521-523)                                                        ‚îÇ
‚îÇ                                                                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ üéØ –ë–´–°–¢–†–´–ô –ü–û–ò–°–ö:                                                                        ‚îÇ
‚îÇ    ‚Ä¢ –¢–∏–ø—ã: CoreUtils (14), ProductDraft (31), RationTabProps (44)                      ‚îÇ
‚îÇ    ‚Ä¢ –£—Ç–∏–ª–∏—Ç—ã: computeDerived() (59), lsGet/lsSet (71-85)                               ‚îÇ
‚îÇ    ‚Ä¢ –ü–∞—Ä—Å–∏–Ω–≥: extractRow() (121), parsePastedSync() (181)                              ‚îÇ
‚îÇ    ‚Ä¢ React: RationTab class (321), render() (481)                                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
*/

// heys_core_v12.ts ‚Äî —è–¥—Ä–æ + –≤–∫–ª–∞–¥–∫–∞ ¬´–†–∞—Ü–∏–æ–Ω¬ª (TypeScript version)

import React from 'react';
import type { HEYSGlobal, Product } from './types/heys';

// Declare global types for React UMD
declare global {
  interface Window {
    React: typeof React;
    HEYS: HEYSGlobal;
  }
}

// Core utilities interface
interface CoreUtils {
  lsGet: (key: string, def: any) => any;
  lsSet: (key: string, val: any) => void;
  toNum: (x: any) => number;
  toNumInput: (v: any) => number;
  round1: (v: number) => number;
  uuid: () => string;
  computeDerived: (p: Partial<Product>) => { carbs100: number; fat100: number; kcal100: number };
}

// Parsed product row interface
interface ParsedRow {
  readonly id: string;
  readonly name: string;
  readonly nums: readonly number[];
}

// Product draft for editing
interface ProductDraft {
  name: string;
  simple100: number;
  complex100: number;
  protein100: number;
  badFat100: number;
  goodFat100: number;
  trans100: number;
  fiber100: number;
  gi: number;
  harmScore: number;
}

// Props interfaces
interface RationTabProps {
  products: Product[];
  setProducts: (products: Product[]) => void;
}

interface ProductModalProps {
  show: boolean;
  onHide: () => void;
  draft: ProductDraft;
  setDraft: (draft: ProductDraft) => void;
  onSave: () => void;
  derived: { carbs100: number; fat100: number; kcal100: number };
}

interface ProductListProps {
  products: Product[];
  filteredProducts: Product[];
  onDelete: (id: string | number) => void;
  onEdit: (product: Product) => void;
}

interface ParseModalProps {
  show: boolean;
  onHide: () => void;
  paste: string;
  setPaste: (paste: string) => void;
  onParse: () => void;
}

// Module implementation
(function (global: Window & typeof globalThis): void {
  const HEYS = (global.HEYS = global.HEYS || ({} as HEYSGlobal));
  const React = global.React;
  const Store = HEYS.store || ({} as any);

  // ===== Utils =====
  const INVIS = /[\u00A0\u1680\u180E\u2000-\u200A\u200B-\u200F\u202F\u205F\u3000\uFEFF]/g;
  const NUM_RE = /[-+]?\d+(?:[\.,]\d+)?/g;

  const round1 = (v: number): number => Math.round(v * 10) / 10;
  const uuid = (): string => Math.random().toString(36).slice(2, 10);

  const toNum = (x: any): number => {
    if (x === undefined || x === null) return 0;
    if (typeof x === 'number') return x;
    const s = String(x).trim().replace(',', '.');
    const n = Number(s);
    return Number.isFinite(n) ? n : 0;
  };

  const toNumInput = (v: any): number => {
    const n = Number(String(v).replace(',', '.'));
    return Number.isFinite(n) ? n : 0;
  };

  function computeDerived(p: Partial<Product>): {
    carbs100: number;
    fat100: number;
    kcal100: number;
  } {
    const carbs100 = toNum(p.simple100) + toNum(p.complex100);
    const fat100 = toNum(p.badFat100) + toNum(p.goodFat100) + toNum(p.trans100);
    const kcal100 = 4 * (toNum(p.protein100) + carbs100) + 8 * fat100;
    return {
      carbs100: round1(carbs100),
      fat100: round1(fat100),
      kcal100: round1(kcal100),
    };
  }

  function lsGet(key: string, def: any): any {
    try {
      const v = localStorage.getItem(key);
      return v ? JSON.parse(v) : def;
    } catch (e) {
      return def;
    }
  }

  function lsSet(key: string, val: any): void {
    try {
      window.HEYS.saveClientKey(key, val);
    } catch (e) {
      // Silent fail
    }
  }

  function isHeaderLine(line: string): boolean {
    const l = line.toLowerCase();
    return (
      l.includes('–Ω–∞–∑–≤–∞–Ω–∏–µ') &&
      (l.includes('–∫–∫–∞–ª') || l.includes('–∫–∞–ª–æ—Ä–∏') || l.includes('—É–≥–ª–µ–≤–æ–¥'))
    );
  }

  function normalizeLine(raw: string): string {
    let s = raw.replace(INVIS, ' ');
    s = s
      .replace(/\u060C/g, ',')
      .replace(/\u066B/g, ',')
      .replace(/\u066C/g, ',')
      .replace(/\u201A/g, ',');
    s = s
      .replace(/\u00B7/g, '.')
      .replace(/[‚Äì‚Äî‚àí]/g, '-')
      .replace(/%/g, '');
    s = s.replace(/\t+/g, ' ').replace(/\s+/g, ' ').trim();
    return s;
  }

  function findTokenPositions(s: string, tokens: string[]): (number | null)[] {
    const positions: (number | null)[] = [];
    let start = 0;
    for (const tok of tokens) {
      const idx = s.indexOf(tok, start);
      positions.push(idx === -1 ? null : idx);
      if (idx !== -1) start = idx + tok.length;
    }
    return positions;
  }

  function extractRow(raw: string): ParsedRow | null {
    const clean = normalizeLine(raw);
    const tokens = clean.match(NUM_RE) || [];
    if (!tokens.length) return null;

    let last = tokens.slice(-12);
    if (last.length < 12)
      last = Array(12 - last.length)
        .fill('0')
        .concat(last);

    const positions = findTokenPositions(clean, last);
    const firstPos = positions[0] ?? clean.length;
    const name = clean.slice(0, firstPos).trim() || '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è';
    const nums = last.map(toNum);

    return { id: uuid(), name, nums };
  }

  // Web Worker proxy for heavy parsePasted
  let _parseWorker: Worker | null = null;

  function getParseWorker(): Worker {
    if (!_parseWorker) {
      _parseWorker = new Worker('parse_worker.js');
    }
    return _parseWorker;
  }

  function parsePasted(text: string): Promise<Product[]> {
    // fallback sync for environments without Worker
    if (typeof Worker === 'undefined') return Promise.resolve(parsePastedSync(text));

    return new Promise((resolve, reject) => {
      const worker = getParseWorker();
      const handler = (e: MessageEvent) => {
        worker.removeEventListener('message', handler);
        resolve(e.data.result && e.data.result.rows ? e.data.result.rows : []);
      };
      worker.addEventListener('message', handler);
      worker.postMessage({ text });
      setTimeout(() => {
        worker.removeEventListener('message', handler);
        reject(new Error('parse timeout'));
      }, 10000);
    });
  }

  // –°–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ –≤–æ—Ä–∫–µ—Ä–∞ –∏ –∫–∞–∫ fallback)
  function parsePastedSync(text: string): Product[] {
    const lines = text
      .split(/\r?\n/)
      .map((l) => l.trim())
      .filter((l) => l.length > 0 && !isHeaderLine(l));
    const rows: Product[] = [];

    for (const raw of lines) {
      const st = extractRow(raw);
      if (!st) continue;

      const [kcal, carbs, simple, complex, protein, fat, bad, good, trans, fiber, gi, harm] =
        st.nums;
      const base = {
        id: uuid(),
        name: st.name,
        simple100: simple,
        complex100: complex,
        protein100: protein,
        badFat100: bad,
        goodFat100: good,
        trans100: trans,
        fiber100: fiber,
        gi: gi,
        harmScore: harm,
      };
      const d = computeDerived(base);

      rows.push({
        ...base,
        carbs100: d.carbs100,
        fat100: d.fat100,
        kcal100: d.kcal100,
      } as Product);
    }
    return rows;
  }

  // React Components
  function RationTab(props: RationTabProps): React.ReactElement {
    const { setProducts } = props;
    const products = Array.isArray(props.products) ? props.products : [];

    // –°–æ—Ö—Ä–∞–Ω—è—Ç—å –ø—Ä–æ–¥—É–∫—Ç—ã –≤ –æ–±–ª–∞–∫–æ –∏ localStorage –ø—Ä–∏ –∫–∞–∂–¥–æ–º –∏–∑–º–µ–Ω–µ–Ω–∏–∏
    React.useEffect(() => {
      // –ù–µ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –ø—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤ –µ—Å–ª–∏ —ç—Ç–æ –ø–µ—Ä–≤–∏—á–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏ –≤–æ–∑–º–æ–∂–Ω–æ –µ—Å—Ç—å –¥–∞–Ω–Ω—ã–µ –≤ –æ–±–ª–∞–∫–µ
      if (products.length === 0) {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –¥–∞–Ω–Ω—ã–µ –≤ localStorage –∏–ª–∏ –æ–±–ª–∞–∫–µ
        const existingProducts =
          window.HEYS?.store?.get?.('heys_products', null) ||
          window.HEYS?.utils?.lsGet?.('heys_products', null);
        if (existingProducts && Array.isArray(existingProducts) && existingProducts.length > 0) {
          // –ï—Å—Ç—å –ø—Ä–æ–¥—É–∫—Ç—ã –≤ storage, –Ω–µ –∑–∞—Ç–∏—Ä–∞–µ–º –∏—Ö –ø—É—Å—Ç—ã–º –º–∞—Å—Å–∏–≤–æ–º
          return;
        }
      }

      if (Array.isArray(products) && window.HEYS?.store?.set) {
        window.HEYS.store.set('heys_products', products);
      } else if (window.HEYS?.utils?.lsSet) {
        // fallback
        window.HEYS.utils.lsSet('heys_products', products);
      }
    }, [products]);

    const [query, setQuery] = React.useState('');
    const [paste, setPaste] = React.useState('');
    const [showModal, setShowModal] = React.useState(false);
    const [showParseModal, setShowParseModal] = React.useState(false);
    const [draft, setDraft] = React.useState<ProductDraft>({
      name: '',
      simple100: 0,
      complex100: 0,
      protein100: 0,
      badFat100: 0,
      goodFat100: 0,
      trans100: 0,
      fiber100: 0,
      gi: 0,
      harmScore: 0,
    });

    const derived = computeDerived(draft);

    // –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ–∏—Å–∫ —Å –∏–Ω–¥–µ–∫—Å–∞—Ü–∏–µ–π
    const searchIndex = React.useMemo(() => {
      const index = new Map<string, number[]>();
      products.forEach((product, idx) => {
        const name = (product.name || '').toLowerCase();
        // –ò–Ω–¥–µ–∫—Å–∏—Ä—É–µ–º –ø–æ –ø–µ—Ä–≤—ã–º –±—É–∫–≤–∞–º –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞
        for (let i = 1; i <= Math.min(name.length, 3); i++) {
          const prefix = name.substring(0, i);
          if (!index.has(prefix)) index.set(prefix, []);
          index.get(prefix)!.push(idx);
        }
      });
      return index;
    }, [products]);

    const filteredProducts = React.useMemo(() => {
      if (!query.trim()) return products;
      const q = query.toLowerCase().trim();

      // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∏–Ω–¥–µ–∫—Å –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞
      const candidates = new Set<number>();
      for (let i = 1; i <= Math.min(q.length, 3); i++) {
        const prefix = q.substring(0, i);
        const indices = searchIndex.get(prefix);
        if (indices) {
          indices.forEach((idx) => candidates.add(idx));
        }
      }

      // –§–∏–ª—å—Ç—Ä—É–µ–º –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤
      return Array.from(candidates)
        .map((idx) => products[idx])
        .filter((product) => product && product.name.toLowerCase().includes(q))
        .slice(0, 100); // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
    }, [products, query, searchIndex]);

    const handleSave = (): void => {
      const newProduct: Product = {
        id: uuid(),
        name: draft.name || '–ù–æ–≤—ã–π –ø—Ä–æ–¥—É–∫—Ç',
        simple100: draft.simple100,
        complex100: draft.complex100,
        protein100: draft.protein100,
        badFat100: draft.badFat100,
        goodFat100: draft.goodFat100,
        trans100: draft.trans100,
        fiber100: draft.fiber100,
        gi: draft.gi,
        harmScore: draft.harmScore,
        carbs100: derived.carbs100,
        fat100: derived.fat100,
        kcal100: derived.kcal100,
      };

      setProducts([...products, newProduct]);
      setShowModal(false);
      setDraft({
        name: '',
        simple100: 0,
        complex100: 0,
        protein100: 0,
        badFat100: 0,
        goodFat100: 0,
        trans100: 0,
        fiber100: 0,
        gi: 0,
        harmScore: 0,
      });
    };

    const handleDelete = (id: string | number): void => {
      setProducts(products.filter((p) => p.id !== id));
    };

    const handleEdit = (product: Product): void => {
      setDraft({
        name: product.name,
        simple100: product.simple100,
        complex100: product.complex100,
        protein100: product.protein100,
        badFat100: product.badFat100,
        goodFat100: product.goodFat100,
        trans100: product.trans100,
        fiber100: product.fiber100,
        gi: product.gi || 0,
        harmScore: product.harmScore || 0,
      });
      setShowModal(true);
    };

    const handleParse = async (): Promise<void> => {
      try {
        const parsed = await parsePasted(paste);
        setProducts([...products, ...parsed]);
        setShowParseModal(false);
        setPaste('');
      } catch (error) {
        console.error('Parse error:', error);
      }
    };

    return React.createElement(
      'div',
      { className: 'ration-tab' },
      React.createElement(
        'div',
        { className: 'ration-controls' },
        React.createElement('input', {
          type: 'text',
          placeholder: '–ü–æ–∏—Å–∫ –ø—Ä–æ–¥—É–∫—Ç–æ–≤...',
          value: query,
          onChange: (e: React.ChangeEvent<HTMLInputElement>) => setQuery(e.target.value),
          className: 'search-input',
        }),
        React.createElement(
          'button',
          {
            onClick: () => setShowModal(true),
            className: 'btn btn-primary',
          },
          '–î–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç',
        ),
        React.createElement(
          'button',
          {
            onClick: () => setShowParseModal(true),
            className: 'btn btn-secondary',
          },
          '–ò–º–ø–æ—Ä—Ç –∏–∑ —Ç–∞–±–ª–∏—Ü—ã',
        ),
      ),
      React.createElement(ProductList, {
        products,
        filteredProducts,
        onDelete: handleDelete,
        onEdit: handleEdit,
      }),
      React.createElement(ProductModal, {
        show: showModal,
        onHide: () => setShowModal(false),
        draft,
        setDraft,
        onSave: handleSave,
        derived,
      }),
      React.createElement(ParseModal, {
        show: showParseModal,
        onHide: () => setShowParseModal(false),
        paste,
        setPaste,
        onParse: handleParse,
      }),
    );
  }

  // Additional component implementations would go here...
  function ProductList(props: ProductListProps): React.ReactElement {
    const { filteredProducts, onDelete, onEdit } = props;

    return React.createElement(
      'div',
      { className: 'product-list' },
      filteredProducts.map((product) =>
        React.createElement(
          'div',
          { key: product.id, className: 'product-item' },
          React.createElement('span', { className: 'product-name' }, product.name),
          React.createElement(
            'span',
            { className: 'product-kcal' },
            `${product.kcal100 || 0} –∫–∫–∞–ª`,
          ),
          React.createElement(
            'button',
            {
              onClick: () => onEdit(product),
              className: 'btn btn-sm btn-outline',
            },
            '–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å',
          ),
          React.createElement(
            'button',
            {
              onClick: () => onDelete(product.id),
              className: 'btn btn-sm btn-danger',
            },
            '–£–¥–∞–ª–∏—Ç—å',
          ),
        ),
      ),
    );
  }

  function ProductModal(props: ProductModalProps): React.ReactElement | null {
    const { show, onHide, draft, setDraft, onSave, derived } = props;

    if (!show) return null;

    return React.createElement(
      'div',
      { className: 'modal' },
      React.createElement(
        'div',
        { className: 'modal-content' },
        React.createElement('h3', null, '–ü—Ä–æ–¥—É–∫—Ç'),
        React.createElement('input', {
          type: 'text',
          placeholder: '–ù–∞–∑–≤–∞–Ω–∏–µ',
          value: draft.name,
          onChange: (e: React.ChangeEvent<HTMLInputElement>) =>
            setDraft({ ...draft, name: e.target.value }),
        }),
        React.createElement(
          'div',
          { className: 'nutrition-grid' },
          [
            'simple100',
            'complex100',
            'protein100',
            'badFat100',
            'goodFat100',
            'trans100',
            'fiber100',
            'gi',
            'harmScore',
          ].map((field) =>
            React.createElement('input', {
              key: field,
              type: 'number',
              placeholder: field,
              value: (draft as any)[field],
              onChange: (e: React.ChangeEvent<HTMLInputElement>) =>
                setDraft({ ...draft, [field]: toNumInput(e.target.value) }),
            }),
          ),
        ),
        React.createElement(
          'div',
          { className: 'derived-info' },
          `–£–≥–ª–µ–≤–æ–¥—ã: ${derived.carbs100}–≥, –ñ–∏—Ä—ã: ${derived.fat100}–≥, –ö–∫–∞–ª: ${derived.kcal100}`,
        ),
        React.createElement(
          'div',
          { className: 'modal-actions' },
          React.createElement('button', { onClick: onSave }, '–°–æ—Ö—Ä–∞–Ω–∏—Ç—å'),
          React.createElement('button', { onClick: onHide }, '–û—Ç–º–µ–Ω–∞'),
        ),
      ),
    );
  }

  function ParseModal(props: ParseModalProps): React.ReactElement | null {
    const { show, onHide, paste, setPaste, onParse } = props;

    if (!show) return null;

    return React.createElement(
      'div',
      { className: 'modal' },
      React.createElement(
        'div',
        { className: 'modal-content' },
        React.createElement('h3', null, '–ò–º–ø–æ—Ä—Ç –ø—Ä–æ–¥—É–∫—Ç–æ–≤'),
        React.createElement('textarea', {
          placeholder: '–í—Å—Ç–∞–≤—å—Ç–µ –¥–∞–Ω–Ω—ã–µ —Ç–∞–±–ª–∏—Ü—ã...',
          value: paste,
          onChange: (e: React.ChangeEvent<HTMLTextAreaElement>) => setPaste(e.target.value),
          rows: 10,
        }),
        React.createElement(
          'div',
          { className: 'modal-actions' },
          React.createElement('button', { onClick: onParse }, '–ò–º–ø–æ—Ä—Ç'),
          React.createElement('button', { onClick: onHide }, '–û—Ç–º–µ–Ω–∞'),
        ),
      ),
    );
  }

  // Export to HEYS namespace
  const utils = {
    lsGet,
    lsSet,
    toNum,
    toNumInput,
    round1,
    uuid,
    computeDerived,
    INVIS,
    NUM_RE,
    parsePasted,
  };

  // Ensure utils exists and extend it
  HEYS.utils = Object.assign(HEYS.utils || {}, utils);

  // Add core functionality (extend HEYS with core property)
  (HEYS as any).core = { RationTab, parsePasted, parsePastedSync };
})(window);
