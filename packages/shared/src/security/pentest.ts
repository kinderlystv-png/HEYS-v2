/**
 * HEYS Penetration Testing Framework
 * Automated security testing and vulnerability assessment
 *
 * @author HEYS Team
 * @version 1.4.0
 * @created 2025-01-31
 */

import { defaultValidator } from '../security';

/**
 * Vulnerability scanner interface
 */
export interface VulnerabilityScanner {
  name: string;
  description: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  scan(target: any): Promise<VulnerabilityResult[]>;
}

/**
 * Vulnerability result
 */
export interface VulnerabilityResult {
  id: string;
  scanner: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  title: string;
  description: string;
  location?: string;
  evidence?: any;
  remediation?: string;
  cve?: string;
  timestamp: Date;
}

/**
 * Penetration test report
 */
export interface PenetrationTestReport {
  id: string;
  targetName: string;
  startTime: Date;
  endTime: Date;
  vulnerabilities: VulnerabilityResult[];
  summary: {
    totalVulnerabilities: number;
    criticalCount: number;
    highCount: number;
    mediumCount: number;
    lowCount: number;
  };
  recommendations: string[];
}

/**
 * XSS vulnerability scanner
 */
export class XSSScanner implements VulnerabilityScanner {
  name = 'XSS Scanner';
  description = 'Cross-Site Scripting vulnerability detection';
  severity = 'high' as const;

  private readonly xssPayloads = [
    '<script>alert("XSS")</script>',
    '"><script>alert("XSS")</script>',
    '<img src=x onerror=alert("XSS")>',
    'javascript:alert("XSS")',
    '<svg onload=alert("XSS")>',
    '\"><script>alert("XSS")</script>',
    '<script>console.log("XSS")</script>',
    '<iframe src="javascript:alert(\'XSS\')"></iframe>',
  ];

  async scan(target: { [key: string]: any }): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];

    for (const [key, value] of Object.entries(target)) {
      if (typeof value === 'string') {
        for (const payload of this.xssPayloads) {
          // Static analysis - NO EXECUTION of dangerous code
          const testValue = value + payload;
          
          // Use safe static analysis instead of DOM manipulation
          const containsDangerousPatterns = this.detectXSSPatterns(testValue);
          
          if (containsDangerousPatterns.length > 0) {
            vulnerabilities.push({
              id: this.generateId(),
              scanner: this.name,
              severity: this.severity,
              title: 'Cross-Site Scripting (XSS) Vulnerability',
              description: `Field "${key}" contains potentially dangerous XSS patterns: ${containsDangerousPatterns.join(', ')}`,
              location: key,
              evidence: { 
                payload, 
                original: value, 
                detectedPatterns: containsDangerousPatterns,
                testValue: testValue.substring(0, 100) // Limited preview for safety
              },
              remediation: 'Implement proper input validation and output encoding with Content Security Policy',
              timestamp: new Date(),
            });
          }
        }
      }
    }

    return vulnerabilities;
  }

  /**
   * Safe static analysis for XSS patterns - NO CODE EXECUTION
   */
  private detectXSSPatterns(input: string): string[] {
    const patterns = [
      { name: 'script_tag', regex: /<script[\s\S]*?>[\s\S]*?<\/script>/gi },
      { name: 'javascript_protocol', regex: /javascript:/gi },
      { name: 'event_handlers', regex: /on\w+\s*=\s*["'][^"']*["']/gi },
      { name: 'svg_onload', regex: /<svg[^>]*onload/gi },
      { name: 'img_onerror', regex: /<img[^>]*onerror/gi },
      { name: 'iframe_javascript', regex: /<iframe[^>]*src\s*=\s*["']javascript:/gi },
      { name: 'data_protocol', regex: /data:text\/html/gi },
      { name: 'vbscript', regex: /vbscript:/gi },
    ];

    const detectedPatterns: string[] = [];
    
    for (const pattern of patterns) {
      if (pattern.regex.test(input)) {
        detectedPatterns.push(pattern.name);
      }
    }

    return detectedPatterns;
  }

  private generateId(): string {
    return `xss-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}

/**
 * SQL Injection scanner
 */
export class SQLInjectionScanner implements VulnerabilityScanner {
  name = 'SQL Injection Scanner';
  description = 'SQL Injection vulnerability detection';
  severity = 'critical' as const;

  private readonly sqlPayloads = [
    "' OR '1'='1",
    "'; DROP TABLE users; --",
    "1' OR '1'='1",
    "admin'--",
    "admin'/*",
    "' OR 1=1--",
    "' UNION SELECT * FROM users--",
    "1; UPDATE users SET password='hacked'--",
  ];

  async scan(target: { [key: string]: any }): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];

    for (const [key, value] of Object.entries(target)) {
      if (typeof value === 'string') {
        for (const payload of this.sqlPayloads) {
          // Check if SQL injection patterns are detected
          if (this.detectSQLInjection(value + payload)) {
            vulnerabilities.push({
              id: this.generateId(),
              scanner: this.name,
              severity: this.severity,
              title: 'SQL Injection Vulnerability',
              description: `Field "${key}" may be vulnerable to SQL injection`,
              location: key,
              evidence: { payload, original: value },
              remediation: 'Use parameterized queries and input validation',
              cve: 'CWE-89',
              timestamp: new Date(),
            });
          }
        }
      }
    }

    return vulnerabilities;
  }

  private detectSQLInjection(input: string): boolean {
    const sqlPatterns = [
      /(\bOR\b|\bAND\b).*?=.*?(\b1\b|\b'1'\b)/i,
      /(\bUNION\b|\bSELECT\b|\bINSERT\b|\bUPDATE\b|\bDELETE\b|\bDROP\b)/i,
      /('|\").*?(\bOR\b|\bAND\b).*?('|\")/i,
      /--|\#|\/\*/,
    ];

    return sqlPatterns.some((pattern) => pattern.test(input));
  }

  private generateId(): string {
    return `sqli-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}

/**
 * Input validation scanner
 */
export class InputValidationScanner implements VulnerabilityScanner {
  name = 'Input Validation Scanner';
  description = 'Input validation and sanitization testing';
  severity = 'medium' as const;

  async scan(target: { [key: string]: any }): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];

    for (const [key, _value] of Object.entries(target)) {
      // Test various validation scenarios
      const testCases = [
        { name: 'Long input', value: 'A'.repeat(10000) },
        { name: 'Special characters', value: '!@#$%^&*()_+{}|:"<>?[]\\;\',./' },
        { name: 'Unicode characters', value: 'ðŸš€ðŸŽ‰ðŸ’»ðŸ”¥âš¡' },
        { name: 'Null bytes', value: 'test\x00test' },
        { name: 'HTML entities', value: '&lt;script&gt;alert(&quot;test&quot;)&lt;/script&gt;' },
      ];

      for (const testCase of testCases) {
        try {
          // Try to validate the test input
          const validation = defaultValidator.validateInput(testCase.value, 'text', {
            sanitize: true,
            required: false,
          });

          // Check if validation is properly handling edge cases
          if (!validation.isValid && !validation.errors?.length) {
            vulnerabilities.push({
              id: this.generateId(),
              scanner: this.name,
              severity: this.severity,
              title: 'Insufficient Input Validation',
              description: `Field "${key}" may not properly validate ${testCase.name}`,
              location: key,
              evidence: { testCase: testCase.name, input: testCase.value },
              remediation: 'Implement comprehensive input validation',
              timestamp: new Date(),
            });
          }
        } catch (error) {
          vulnerabilities.push({
            id: this.generateId(),
            scanner: this.name,
            severity: 'high',
            title: 'Input Validation Error',
            description: `Field "${key}" causes validation errors with ${testCase.name}`,
            location: key,
            evidence: { testCase: testCase.name, error: (error as Error).message },
            remediation: 'Fix input validation error handling',
            timestamp: new Date(),
          });
        }
      }
    }

    return vulnerabilities;
  }

  private generateId(): string {
    return `input-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}

/**
 * Authentication bypass scanner
 */
export class AuthBypassScanner implements VulnerabilityScanner {
  name = 'Authentication Bypass Scanner';
  description = 'Authentication and authorization vulnerability testing';
  severity = 'critical' as const;

  async scan(target: { [key: string]: any }): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];

    // Check for common authentication bypass patterns
    const authFields = ['password', 'token', 'auth', 'authorization', 'session'];
    const bypassAttempts = [
      '',
      null,
      undefined,
      'admin',
      'password',
      '123456',
      'null',
      'false',
      '0',
      '[]',
      '{}',
    ];

    for (const field of authFields) {
      if (target.hasOwnProperty(field)) {
        for (const attempt of bypassAttempts) {
          // Simulate bypass attempt (removed unused variable)

          vulnerabilities.push({
            id: this.generateId(),
            scanner: this.name,
            severity: this.severity,
            title: 'Potential Authentication Bypass',
            description: `Authentication field "${field}" should be tested against bypass attempts`,
            location: field,
            evidence: { field, bypassAttempt: attempt },
            remediation: 'Implement secure authentication validation and proper session management',
            cve: 'CWE-287',
            timestamp: new Date(),
          });
        }
      }
    }

    return vulnerabilities;
  }

  private generateId(): string {
    return `auth-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}

/**
 * Main penetration testing framework
 */
export class PenetrationTestFramework {
  private scanners: VulnerabilityScanner[] = [];

  constructor() {
    // Register default scanners
    this.registerScanner(new XSSScanner());
    this.registerScanner(new SQLInjectionScanner());
    this.registerScanner(new InputValidationScanner());
    this.registerScanner(new AuthBypassScanner());
  }

  /**
   * Register a new vulnerability scanner
   */
  registerScanner(scanner: VulnerabilityScanner): void {
    this.scanners.push(scanner);
  }

  /**
   * Run comprehensive penetration test
   */
  async runPenetrationTest(
    targetName: string,
    target: any,
    options: {
      includeScanners?: string[];
      excludeScanners?: string[];
      severity?: ('low' | 'medium' | 'high' | 'critical')[];
    } = {},
  ): Promise<PenetrationTestReport> {
    const startTime = new Date();
    let allVulnerabilities: VulnerabilityResult[] = [];

    // Filter scanners based on options
    let scannersToRun = this.scanners;

    if (options.includeScanners) {
      scannersToRun = scannersToRun.filter((s) => options.includeScanners!.includes(s.name));
    }

    if (options.excludeScanners) {
      scannersToRun = scannersToRun.filter((s) => !options.excludeScanners!.includes(s.name));
    }

    if (options.severity) {
      scannersToRun = scannersToRun.filter((s) => options.severity!.includes(s.severity));
    }

    // Run all scanners
    for (const scanner of scannersToRun) {
      try {
        console.log(`Running ${scanner.name}...`);
        const vulnerabilities = await scanner.scan(target);
        allVulnerabilities = allVulnerabilities.concat(vulnerabilities);
      } catch (error) {
        console.error(`Scanner ${scanner.name} failed:`, error);
      }
    }

    const endTime = new Date();

    // Generate summary
    const summary = {
      totalVulnerabilities: allVulnerabilities.length,
      criticalCount: allVulnerabilities.filter((v) => v.severity === 'critical').length,
      highCount: allVulnerabilities.filter((v) => v.severity === 'high').length,
      mediumCount: allVulnerabilities.filter((v) => v.severity === 'medium').length,
      lowCount: allVulnerabilities.filter((v) => v.severity === 'low').length,
    };

    // Generate recommendations
    const recommendations = this.generateRecommendations(allVulnerabilities);

    return {
      id: `pentest-${Date.now()}`,
      targetName,
      startTime,
      endTime,
      vulnerabilities: allVulnerabilities,
      summary,
      recommendations,
    };
  }

  /**
   * Generate security recommendations based on vulnerabilities
   */
  private generateRecommendations(vulnerabilities: VulnerabilityResult[]): string[] {
    const recommendations = new Set<string>();

    vulnerabilities.forEach((vuln) => {
      if (vuln.remediation) {
        recommendations.add(vuln.remediation);
      }

      // Add general recommendations based on vulnerability type
      if (vuln.scanner.includes('XSS')) {
        recommendations.add('Implement Content Security Policy (CSP) headers');
        recommendations.add('Use secure templating engines with auto-escaping');
      }

      if (vuln.scanner.includes('SQL')) {
        recommendations.add('Use parameterized queries or ORM');
        recommendations.add('Implement principle of least privilege for database access');
      }

      if (vuln.scanner.includes('Auth')) {
        recommendations.add('Implement multi-factor authentication');
        recommendations.add('Use secure session management');
        recommendations.add('Implement account lockout mechanisms');
      }
    });

    // Add general security recommendations
    if (vulnerabilities.length > 0) {
      recommendations.add('Conduct regular security audits');
      recommendations.add('Implement security monitoring and logging');
      recommendations.add('Keep all dependencies updated');
      recommendations.add('Provide security training for development team');
    }

    return Array.from(recommendations);
  }

  /**
   * Export test report to JSON
   */
  exportReport(report: PenetrationTestReport): string {
    return JSON.stringify(report, null, 2);
  }

  /**
   * Generate HTML report
   */
  generateHtmlReport(report: PenetrationTestReport): string {
    const severityColors = {
      critical: '#dc3545',
      high: '#fd7e14',
      medium: '#ffc107',
      low: '#198754',
    };

    return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Penetration Test Report - ${report.targetName}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .header { background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 30px; }
        .summary { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .summary-card { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .vulnerability { background: white; padding: 20px; margin-bottom: 20px; border-left: 4px solid #ddd; border-radius: 4px; }
        .critical { border-left-color: ${severityColors.critical}; }
        .high { border-left-color: ${severityColors.high}; }
        .medium { border-left-color: ${severityColors.medium}; }
        .low { border-left-color: ${severityColors.low}; }
        .recommendations { background: #e7f3ff; padding: 20px; border-radius: 8px; margin-top: 30px; }
        .severity-badge { padding: 4px 8px; color: white; border-radius: 4px; font-size: 12px; }
        code { background: #f1f3f4; padding: 2px 4px; border-radius: 3px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Penetration Test Report</h1>
        <p><strong>Target:</strong> ${report.targetName}</p>
        <p><strong>Test Period:</strong> ${report.startTime.toISOString()} - ${report.endTime.toISOString()}</p>
        <p><strong>Duration:</strong> ${Math.round((report.endTime.getTime() - report.startTime.getTime()) / 1000)} seconds</p>
    </div>

    <div class="summary">
        <div class="summary-card">
            <h3>Total Vulnerabilities</h3>
            <h2>${report.summary.totalVulnerabilities}</h2>
        </div>
        <div class="summary-card">
            <h3>Critical</h3>
            <h2 style="color: ${severityColors.critical}">${report.summary.criticalCount}</h2>
        </div>
        <div class="summary-card">
            <h3>High</h3>
            <h2 style="color: ${severityColors.high}">${report.summary.highCount}</h2>
        </div>
        <div class="summary-card">
            <h3>Medium</h3>
            <h2 style="color: ${severityColors.medium}">${report.summary.mediumCount}</h2>
        </div>
        <div class="summary-card">
            <h3>Low</h3>
            <h2 style="color: ${severityColors.low}">${report.summary.lowCount}</h2>
        </div>
    </div>

    <h2>Vulnerabilities</h2>
    ${report.vulnerabilities
      .map(
        (vuln) => `
        <div class="vulnerability ${vuln.severity}">
            <h3>${vuln.title}</h3>
            <span class="severity-badge" style="background-color: ${severityColors[vuln.severity]}">${vuln.severity.toUpperCase()}</span>
            <p><strong>Scanner:</strong> ${vuln.scanner}</p>
            <p><strong>Location:</strong> ${vuln.location || 'N/A'}</p>
            <p><strong>Description:</strong> ${vuln.description}</p>
            ${vuln.remediation ? `<p><strong>Remediation:</strong> ${vuln.remediation}</p>` : ''}
            ${vuln.evidence ? `<p><strong>Evidence:</strong> <code>${JSON.stringify(vuln.evidence, null, 2)}</code></p>` : ''}
            ${vuln.cve ? `<p><strong>CVE:</strong> ${vuln.cve}</p>` : ''}
            <p><strong>Timestamp:</strong> ${vuln.timestamp.toISOString()}</p>
        </div>
    `,
      )
      .join('')}

    <div class="recommendations">
        <h2>Recommendations</h2>
        <ul>
            ${report.recommendations.map((rec) => `<li>${rec}</li>`).join('')}
        </ul>
    </div>
</body>
</html>
    `;
  }
}

/**
 * Default penetration testing framework instance
 */
export const defaultPentestFramework = new PenetrationTestFramework();
