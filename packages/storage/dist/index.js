var o=class{adapters=new Map;defaultAdapter="memory";addAdapter(e,t){this.adapters.set(e,t);}setDefaultAdapter(e){if(!this.adapters.has(e))throw new Error(`Adapter ${e} not found`);this.defaultAdapter=e;}getAdapter(e){let t=e||this.defaultAdapter,r=this.adapters.get(t);if(!r)throw new Error(`Adapter ${t} not configured`);return r}async get(e,t,r){let a=this.getAdapter(r),s=await a.get(e);if(!s)return null;if(s.expiresAt&&s.expiresAt<new Date)return await a.delete(e),null;if(t)try{return t.parse(s.value)}catch(i){return console.warn(`Storage validation failed for key ${e}:`,i),null}return s.value}async set(e,t,r,a){await this.getAdapter(a).set(e,t,r);}async delete(e,t){await this.getAdapter(t).delete(e);}async has(e,t){return this.getAdapter(t).has(e)}async clear(e){await this.getAdapter(e).clear();}async keys(e){return this.getAdapter(e).keys()}async setMany(e,t,r){let a=Object.entries(e).map(([s,i])=>this.set(s,i,t,r));await Promise.all(a);}async getMany(e,t,r){let a=e.map(async i=>({key:i,value:await this.get(i,t,r)}));return (await Promise.all(a)).reduce((i,{key:c,value:p})=>(i[c]=p,i),{})}async deleteMany(e,t){let r=e.map(a=>this.delete(a,t));await Promise.all(r);}},d=class{storage=new Map;async get(e){let t=this.storage.get(e);return t?t.expiresAt&&t.expiresAt<new Date?(this.storage.delete(e),null):t:null}async set(e,t,r){let a=new Date,s=this.storage.get(e);this.storage.set(e,{id:s?.id||crypto.randomUUID(),key:e,value:t,...s?.metadata&&{metadata:s.metadata},createdAt:s?.createdAt||a,updatedAt:a,...r&&{expiresAt:new Date(a.getTime()+r*1e3)}});}async delete(e){this.storage.delete(e);}async has(e){return await this.get(e)!==null}async clear(){this.storage.clear();}async keys(){let e=Array.from(this.storage.keys()),t=[];for(let r of e)await this.has(r)&&t.push(r);return t}size(){return this.storage.size}getStats(){let e=this.storage.size,t=0;for(let r of this.storage.values())r.expiresAt&&r.expiresAt<new Date&&t++;return {size:e,totalItems:e,expiredItems:t}}cleanupExpired(){let e=0,t=new Date;for(let[r,a]of this.storage.entries())a.expiresAt&&a.expiresAt<t&&(this.storage.delete(r),e++);return e}},g=class{prefix;constructor(e="heys_"){if(this.prefix=e,typeof window>"u"||!window.localStorage)throw new Error("LocalStorage is not available")}getKey(e){return `${this.prefix}${e}`}async get(e){try{let t=localStorage.getItem(this.getKey(e));if(!t)return null;let r=JSON.parse(t);return r.createdAt=new Date(r.createdAt),r.updatedAt=new Date(r.updatedAt),r.expiresAt&&(r.expiresAt=new Date(r.expiresAt)),r.expiresAt&&r.expiresAt<new Date?(await this.delete(e),null):r}catch(t){return console.error("LocalStorage get error:",t),null}}async set(e,t,r){try{let a=new Date,s=await this.get(e),i={id:s?.id||crypto.randomUUID(),key:e,value:t,...s?.metadata&&{metadata:s.metadata},createdAt:s?.createdAt||a,updatedAt:a,...r&&{expiresAt:new Date(a.getTime()+r*1e3)}};localStorage.setItem(this.getKey(e),JSON.stringify(i));}catch(a){throw console.error("LocalStorage set error:",a),a}}async delete(e){localStorage.removeItem(this.getKey(e));}async has(e){return await this.get(e)!==null}async clear(){let e=await this.keys();for(let t of e)await this.delete(t);}async keys(){let e=[];for(let t=0;t<localStorage.length;t++){let r=localStorage.key(t);if(r&&r.startsWith(this.prefix)){let a=r.slice(this.prefix.length);await this.has(a)&&e.push(a);}}return e}},l=new o;l.addAdapter("memory",new d);if(typeof window<"u"&&window.localStorage)try{l.addAdapter("localStorage",new g);}catch(n){console.warn("Failed to initialize LocalStorage adapter:",n);}var m=l,u=()=>({get:n=>localStorage.getItem(n),set:(n,e)=>localStorage.setItem(n,e)});

export { g as LocalStorageAdapter, d as MemoryStorageAdapter, o as StorageService, u as createStorage, m as default, l as storage };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map