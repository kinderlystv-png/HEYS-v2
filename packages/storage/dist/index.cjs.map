{"version":3,"sources":["../src/index.ts"],"names":["StorageService","name","adapter","adapterName","key","schema","item","error","value","ttl","items","promises","keys","acc","MemoryStorageAdapter","now","existing","allKeys","validKeys","totalItems","expiredItems","cleaned","LocalStorageAdapter","prefix","data","i","unprefixedKey","storage","src_default","createStorage"],"mappings":"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","sourcesContent":["// Storage service with multiple adapters and validation\r\nimport { z } from 'zod';\r\n\r\nexport interface StorageItem {\r\n  id: string;\r\n  key: string;\r\n  value: unknown;\r\n  metadata?: Record<string, any>;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n  expiresAt?: Date;\r\n}\r\n\r\nexport interface StorageAdapter {\r\n  get(key: string): Promise<StorageItem | null>;\r\n  set(key: string, value: unknown, ttl?: number): Promise<void>;\r\n  delete(key: string): Promise<void>;\r\n  has(key: string): Promise<boolean>;\r\n  clear(): Promise<void>;\r\n  keys(): Promise<string[]>;\r\n}\r\n\r\nexport class StorageService {\r\n  private adapters: Map<string, StorageAdapter> = new Map();\r\n  private defaultAdapter: string = 'memory';\r\n\r\n  addAdapter(name: string, adapter: StorageAdapter): void {\r\n    this.adapters.set(name, adapter);\r\n  }\r\n\r\n  setDefaultAdapter(name: string): void {\r\n    if (!this.adapters.has(name)) {\r\n      throw new Error(`Adapter ${name} not found`);\r\n    }\r\n    this.defaultAdapter = name;\r\n  }\r\n\r\n  getAdapter(name?: string): StorageAdapter {\r\n    const adapterName = name || this.defaultAdapter;\r\n    const adapter = this.adapters.get(adapterName);\r\n    if (!adapter) {\r\n      throw new Error(`Adapter ${adapterName} not configured`);\r\n    }\r\n    return adapter;\r\n  }\r\n\r\n  async get<T>(key: string, schema?: z.ZodSchema<T>, adapterName?: string): Promise<T | null> {\r\n    const adapter = this.getAdapter(adapterName);\r\n\r\n    const item = await adapter.get(key);\r\n    if (!item) return null;\r\n\r\n    // Check expiration\r\n    if (item.expiresAt && item.expiresAt < new Date()) {\r\n      await adapter.delete(key);\r\n      return null;\r\n    }\r\n\r\n    // Validate with schema if provided\r\n    if (schema) {\r\n      try {\r\n        return schema.parse(item.value);\r\n      } catch (error) {\r\n        console.warn(`Storage validation failed for key ${key}:`, error);\r\n        return null;\r\n      }\r\n    }\r\n\r\n    return item.value as T;\r\n  }\r\n\r\n  async set<T>(key: string, value: T, ttl?: number, adapterName?: string): Promise<void> {\r\n    const adapter = this.getAdapter(adapterName);\r\n    await adapter.set(key, value, ttl);\r\n  }\r\n\r\n  async delete(key: string, adapterName?: string): Promise<void> {\r\n    const adapter = this.getAdapter(adapterName);\r\n    await adapter.delete(key);\r\n  }\r\n\r\n  async has(key: string, adapterName?: string): Promise<boolean> {\r\n    const adapter = this.getAdapter(adapterName);\r\n    return adapter.has(key);\r\n  }\r\n\r\n  async clear(adapterName?: string): Promise<void> {\r\n    const adapter = this.getAdapter(adapterName);\r\n    await adapter.clear();\r\n  }\r\n\r\n  async keys(adapterName?: string): Promise<string[]> {\r\n    const adapter = this.getAdapter(adapterName);\r\n    return adapter.keys();\r\n  }\r\n\r\n  // Bulk operations\r\n  async setMany(items: Record<string, unknown>, ttl?: number, adapterName?: string): Promise<void> {\r\n    const promises = Object.entries(items).map(([key, value]) =>\r\n      this.set(key, value, ttl, adapterName),\r\n    );\r\n    await Promise.all(promises);\r\n  }\r\n\r\n  async getMany<T>(\r\n    keys: string[],\r\n    schema?: z.ZodSchema<T>,\r\n    adapterName?: string,\r\n  ): Promise<Record<string, T | null>> {\r\n    const promises = keys.map(async (key) => ({\r\n      key,\r\n      value: await this.get<T>(key, schema, adapterName),\r\n    }));\r\n\r\n    const results = await Promise.all(promises);\r\n    return results.reduce(\r\n      (acc, { key, value }) => {\r\n        acc[key] = value;\r\n        return acc;\r\n      },\r\n      {} as Record<string, T | null>,\r\n    );\r\n  }\r\n\r\n  async deleteMany(keys: string[], adapterName?: string): Promise<void> {\r\n    const promises = keys.map((key) => this.delete(key, adapterName));\r\n    await Promise.all(promises);\r\n  }\r\n}\r\n\r\n// Memory adapter implementation\r\nexport class MemoryStorageAdapter implements StorageAdapter {\r\n  private storage = new Map<string, StorageItem>();\r\n\r\n  async get(key: string): Promise<StorageItem | null> {\r\n    const item = this.storage.get(key);\r\n    if (!item) return null;\r\n\r\n    // Check expiration\r\n    if (item.expiresAt && item.expiresAt < new Date()) {\r\n      this.storage.delete(key);\r\n      return null;\r\n    }\r\n\r\n    return item;\r\n  }\r\n\r\n  async set(key: string, value: unknown, ttl?: number): Promise<void> {\r\n    const now = new Date();\r\n    const existing = this.storage.get(key);\r\n\r\n    this.storage.set(key, {\r\n      id: existing?.id || crypto.randomUUID(),\r\n      key,\r\n      value,\r\n      ...(existing?.metadata && { metadata: existing.metadata }),\r\n      createdAt: existing?.createdAt || now,\r\n      updatedAt: now,\r\n      ...(ttl && { expiresAt: new Date(now.getTime() + ttl * 1000) }),\r\n    });\r\n  }\r\n\r\n  async delete(key: string): Promise<void> {\r\n    this.storage.delete(key);\r\n  }\r\n\r\n  async has(key: string): Promise<boolean> {\r\n    const item = await this.get(key);\r\n    return item !== null;\r\n  }\r\n\r\n  async clear(): Promise<void> {\r\n    this.storage.clear();\r\n  }\r\n\r\n  async keys(): Promise<string[]> {\r\n    const allKeys = Array.from(this.storage.keys());\r\n    const validKeys: string[] = [];\r\n\r\n    for (const key of allKeys) {\r\n      if (await this.has(key)) {\r\n        validKeys.push(key);\r\n      }\r\n    }\r\n\r\n    return validKeys;\r\n  }\r\n\r\n  // Memory-specific methods\r\n  size(): number {\r\n    return this.storage.size;\r\n  }\r\n\r\n  getStats(): { size: number; totalItems: number; expiredItems: number } {\r\n    const totalItems = this.storage.size;\r\n    let expiredItems = 0;\r\n\r\n    for (const item of this.storage.values()) {\r\n      if (item.expiresAt && item.expiresAt < new Date()) {\r\n        expiredItems++;\r\n      }\r\n    }\r\n\r\n    return {\r\n      size: totalItems,\r\n      totalItems,\r\n      expiredItems,\r\n    };\r\n  }\r\n\r\n  cleanupExpired(): number {\r\n    let cleaned = 0;\r\n    const now = new Date();\r\n\r\n    for (const [key, item] of this.storage.entries()) {\r\n      if (item.expiresAt && item.expiresAt < now) {\r\n        this.storage.delete(key);\r\n        cleaned++;\r\n      }\r\n    }\r\n\r\n    return cleaned;\r\n  }\r\n}\r\n\r\n// LocalStorage adapter for browser environments\r\nexport class LocalStorageAdapter implements StorageAdapter {\r\n  private prefix: string;\r\n\r\n  constructor(prefix: string = 'heys_') {\r\n    this.prefix = prefix;\r\n    if (typeof window === 'undefined' || !window.localStorage) {\r\n      throw new Error('LocalStorage is not available');\r\n    }\r\n  }\r\n\r\n  private getKey(key: string): string {\r\n    return `${this.prefix}${key}`;\r\n  }\r\n\r\n  async get(key: string): Promise<StorageItem | null> {\r\n    try {\r\n      const data = localStorage.getItem(this.getKey(key));\r\n      if (!data) return null;\r\n\r\n      const item: StorageItem = JSON.parse(data);\r\n\r\n      // Convert date strings back to Date objects\r\n      item.createdAt = new Date(item.createdAt);\r\n      item.updatedAt = new Date(item.updatedAt);\r\n      if (item.expiresAt) {\r\n        item.expiresAt = new Date(item.expiresAt);\r\n      }\r\n\r\n      // Check expiration\r\n      if (item.expiresAt && item.expiresAt < new Date()) {\r\n        await this.delete(key);\r\n        return null;\r\n      }\r\n\r\n      return item;\r\n    } catch (error) {\r\n      console.error('LocalStorage get error:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async set(key: string, value: unknown, ttl?: number): Promise<void> {\r\n    try {\r\n      const now = new Date();\r\n      const existing = await this.get(key);\r\n\r\n      const item: StorageItem = {\r\n        id: existing?.id || crypto.randomUUID(),\r\n        key,\r\n        value,\r\n        ...(existing?.metadata && { metadata: existing.metadata }),\r\n        createdAt: existing?.createdAt || now,\r\n        updatedAt: now,\r\n        ...(ttl && { expiresAt: new Date(now.getTime() + ttl * 1000) }),\r\n      };\r\n\r\n      localStorage.setItem(this.getKey(key), JSON.stringify(item));\r\n    } catch (error) {\r\n      console.error('LocalStorage set error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async delete(key: string): Promise<void> {\r\n    localStorage.removeItem(this.getKey(key));\r\n  }\r\n\r\n  async has(key: string): Promise<boolean> {\r\n    const item = await this.get(key);\r\n    return item !== null;\r\n  }\r\n\r\n  async clear(): Promise<void> {\r\n    const keys = await this.keys();\r\n    for (const key of keys) {\r\n      await this.delete(key);\r\n    }\r\n  }\r\n\r\n  async keys(): Promise<string[]> {\r\n    const keys: string[] = [];\r\n    for (let i = 0; i < localStorage.length; i++) {\r\n      const key = localStorage.key(i);\r\n      if (key && key.startsWith(this.prefix)) {\r\n        const unprefixedKey = key.slice(this.prefix.length);\r\n        if (await this.has(unprefixedKey)) {\r\n          keys.push(unprefixedKey);\r\n        }\r\n      }\r\n    }\r\n    return keys;\r\n  }\r\n}\r\n\r\n// Create default storage instance\r\nexport const storage = new StorageService();\r\n\r\n// Add default memory adapter\r\nstorage.addAdapter('memory', new MemoryStorageAdapter());\r\n\r\n// Add localStorage adapter if available\r\nif (typeof window !== 'undefined' && window.localStorage) {\r\n  try {\r\n    storage.addAdapter('localStorage', new LocalStorageAdapter());\r\n  } catch (error) {\r\n    console.warn('Failed to initialize LocalStorage adapter:', error);\r\n  }\r\n}\r\n\r\nexport default storage;\r\n\r\n// Legacy compatibility\r\nexport const createStorage = () => ({\r\n  get: (key: string) => localStorage.getItem(key),\r\n  set: (key: string, value: string) => localStorage.setItem(key, value),\r\n});\r\n"]}