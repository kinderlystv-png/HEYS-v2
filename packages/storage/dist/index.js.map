{"version":3,"sources":["../src/index.ts"],"names":["StorageService","name","adapter","adapterName","key","schema","item","error","value","ttl","items","promises","keys","acc","MemoryStorageAdapter","now","existing","allKeys","validKeys","totalItems","expiredItems","cleaned","LocalStorageAdapter","prefix","data","i","unprefixedKey","storage","src_default","createStorage"],"mappings":"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","sourcesContent":["// Storage service with multiple adapters and validation\nimport { z } from 'zod';\n\nexport interface StorageItem {\n  id: string;\n  key: string;\n  value: unknown;\n  metadata?: Record<string, any>;\n  createdAt: Date;\n  updatedAt: Date;\n  expiresAt?: Date;\n}\n\nexport interface StorageAdapter {\n  get(key: string): Promise<StorageItem | null>;\n  set(key: string, value: unknown, ttl?: number): Promise<void>;\n  delete(key: string): Promise<void>;\n  has(key: string): Promise<boolean>;\n  clear(): Promise<void>;\n  keys(): Promise<string[]>;\n}\n\nexport class StorageService {\n  private adapters: Map<string, StorageAdapter> = new Map();\n  private defaultAdapter: string = 'memory';\n\n  addAdapter(name: string, adapter: StorageAdapter): void {\n    this.adapters.set(name, adapter);\n  }\n\n  setDefaultAdapter(name: string): void {\n    if (!this.adapters.has(name)) {\n      throw new Error(`Adapter ${name} not found`);\n    }\n    this.defaultAdapter = name;\n  }\n\n  getAdapter(name?: string): StorageAdapter {\n    const adapterName = name || this.defaultAdapter;\n    const adapter = this.adapters.get(adapterName);\n    if (!adapter) {\n      throw new Error(`Adapter ${adapterName} not configured`);\n    }\n    return adapter;\n  }\n\n  async get<T>(key: string, schema?: z.ZodSchema<T>, adapterName?: string): Promise<T | null> {\n    const adapter = this.getAdapter(adapterName);\n    \n    const item = await adapter.get(key);\n    if (!item) return null;\n    \n    // Check expiration\n    if (item.expiresAt && item.expiresAt < new Date()) {\n      await adapter.delete(key);\n      return null;\n    }\n    \n    // Validate with schema if provided\n    if (schema) {\n      try {\n        return schema.parse(item.value);\n      } catch (error) {\n        console.warn(`Storage validation failed for key ${key}:`, error);\n        return null;\n      }\n    }\n    \n    return item.value as T;\n  }\n\n  async set<T>(key: string, value: T, ttl?: number, adapterName?: string): Promise<void> {\n    const adapter = this.getAdapter(adapterName);\n    await adapter.set(key, value, ttl);\n  }\n\n  async delete(key: string, adapterName?: string): Promise<void> {\n    const adapter = this.getAdapter(adapterName);\n    await adapter.delete(key);\n  }\n\n  async has(key: string, adapterName?: string): Promise<boolean> {\n    const adapter = this.getAdapter(adapterName);\n    return adapter.has(key);\n  }\n\n  async clear(adapterName?: string): Promise<void> {\n    const adapter = this.getAdapter(adapterName);\n    await adapter.clear();\n  }\n\n  async keys(adapterName?: string): Promise<string[]> {\n    const adapter = this.getAdapter(adapterName);\n    return adapter.keys();\n  }\n\n  // Bulk operations\n  async setMany(items: Record<string, unknown>, ttl?: number, adapterName?: string): Promise<void> {\n    const promises = Object.entries(items).map(([key, value]) =>\n      this.set(key, value, ttl, adapterName)\n    );\n    await Promise.all(promises);\n  }\n\n  async getMany<T>(keys: string[], schema?: z.ZodSchema<T>, adapterName?: string): Promise<Record<string, T | null>> {\n    const promises = keys.map(async (key) => ({\n      key,\n      value: await this.get<T>(key, schema, adapterName),\n    }));\n    \n    const results = await Promise.all(promises);\n    return results.reduce((acc, { key, value }) => {\n      acc[key] = value;\n      return acc;\n    }, {} as Record<string, T | null>);\n  }\n\n  async deleteMany(keys: string[], adapterName?: string): Promise<void> {\n    const promises = keys.map(key => this.delete(key, adapterName));\n    await Promise.all(promises);\n  }\n}\n\n// Memory adapter implementation\nexport class MemoryStorageAdapter implements StorageAdapter {\n  private storage = new Map<string, StorageItem>();\n\n  async get(key: string): Promise<StorageItem | null> {\n    const item = this.storage.get(key);\n    if (!item) return null;\n    \n    // Check expiration\n    if (item.expiresAt && item.expiresAt < new Date()) {\n      this.storage.delete(key);\n      return null;\n    }\n    \n    return item;\n  }\n\n  async set(key: string, value: unknown, ttl?: number): Promise<void> {\n    const now = new Date();\n    const existing = this.storage.get(key);\n    \n    this.storage.set(key, {\n      id: existing?.id || crypto.randomUUID(),\n      key,\n      value,\n      ...(existing?.metadata && { metadata: existing.metadata }),\n      createdAt: existing?.createdAt || now,\n      updatedAt: now,\n      ...(ttl && { expiresAt: new Date(now.getTime() + ttl * 1000) }),\n    });\n  }\n\n  async delete(key: string): Promise<void> {\n    this.storage.delete(key);\n  }\n\n  async has(key: string): Promise<boolean> {\n    const item = await this.get(key);\n    return item !== null;\n  }\n\n  async clear(): Promise<void> {\n    this.storage.clear();\n  }\n\n  async keys(): Promise<string[]> {\n    const allKeys = Array.from(this.storage.keys());\n    const validKeys: string[] = [];\n    \n    for (const key of allKeys) {\n      if (await this.has(key)) {\n        validKeys.push(key);\n      }\n    }\n    \n    return validKeys;\n  }\n\n  // Memory-specific methods\n  size(): number {\n    return this.storage.size;\n  }\n\n  getStats(): { size: number; totalItems: number; expiredItems: number } {\n    const totalItems = this.storage.size;\n    let expiredItems = 0;\n    \n    for (const item of this.storage.values()) {\n      if (item.expiresAt && item.expiresAt < new Date()) {\n        expiredItems++;\n      }\n    }\n    \n    return {\n      size: totalItems,\n      totalItems,\n      expiredItems,\n    };\n  }\n\n  cleanupExpired(): number {\n    let cleaned = 0;\n    const now = new Date();\n    \n    for (const [key, item] of this.storage.entries()) {\n      if (item.expiresAt && item.expiresAt < now) {\n        this.storage.delete(key);\n        cleaned++;\n      }\n    }\n    \n    return cleaned;\n  }\n}\n\n// LocalStorage adapter for browser environments\nexport class LocalStorageAdapter implements StorageAdapter {\n  private prefix: string;\n\n  constructor(prefix: string = 'heys_') {\n    this.prefix = prefix;\n    if (typeof window === 'undefined' || !window.localStorage) {\n      throw new Error('LocalStorage is not available');\n    }\n  }\n\n  private getKey(key: string): string {\n    return `${this.prefix}${key}`;\n  }\n\n  async get(key: string): Promise<StorageItem | null> {\n    try {\n      const data = localStorage.getItem(this.getKey(key));\n      if (!data) return null;\n      \n      const item: StorageItem = JSON.parse(data);\n      \n      // Convert date strings back to Date objects\n      item.createdAt = new Date(item.createdAt);\n      item.updatedAt = new Date(item.updatedAt);\n      if (item.expiresAt) {\n        item.expiresAt = new Date(item.expiresAt);\n      }\n      \n      // Check expiration\n      if (item.expiresAt && item.expiresAt < new Date()) {\n        await this.delete(key);\n        return null;\n      }\n      \n      return item;\n    } catch (error) {\n      console.error('LocalStorage get error:', error);\n      return null;\n    }\n  }\n\n  async set(key: string, value: unknown, ttl?: number): Promise<void> {\n    try {\n      const now = new Date();\n      const existing = await this.get(key);\n      \n      const item: StorageItem = {\n        id: existing?.id || crypto.randomUUID(),\n        key,\n        value,\n        ...(existing?.metadata && { metadata: existing.metadata }),\n        createdAt: existing?.createdAt || now,\n        updatedAt: now,\n        ...(ttl && { expiresAt: new Date(now.getTime() + ttl * 1000) }),\n      };\n      \n      localStorage.setItem(this.getKey(key), JSON.stringify(item));\n    } catch (error) {\n      console.error('LocalStorage set error:', error);\n      throw error;\n    }\n  }\n\n  async delete(key: string): Promise<void> {\n    localStorage.removeItem(this.getKey(key));\n  }\n\n  async has(key: string): Promise<boolean> {\n    const item = await this.get(key);\n    return item !== null;\n  }\n\n  async clear(): Promise<void> {\n    const keys = await this.keys();\n    for (const key of keys) {\n      await this.delete(key);\n    }\n  }\n\n  async keys(): Promise<string[]> {\n    const keys: string[] = [];\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key && key.startsWith(this.prefix)) {\n        const unprefixedKey = key.slice(this.prefix.length);\n        if (await this.has(unprefixedKey)) {\n          keys.push(unprefixedKey);\n        }\n      }\n    }\n    return keys;\n  }\n}\n\n// Create default storage instance\nexport const storage = new StorageService();\n\n// Add default memory adapter\nstorage.addAdapter('memory', new MemoryStorageAdapter());\n\n// Add localStorage adapter if available\nif (typeof window !== 'undefined' && window.localStorage) {\n  try {\n    storage.addAdapter('localStorage', new LocalStorageAdapter());\n  } catch (error) {\n    console.warn('Failed to initialize LocalStorage adapter:', error);\n  }\n}\n\nexport default storage;\n\n// Legacy compatibility\nexport const createStorage = () => ({\n  get: (key: string) => localStorage.getItem(key),\n  set: (key: string, value: string) => localStorage.setItem(key, value),\n});\n"]}