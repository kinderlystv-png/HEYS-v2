Архитектурно «мобильная версия веб-приложения» — это не копия сайта, а ещё один клиент к тому же домену. Ниже — как это обычно делается, если делать правильно, без костылей.

---

### 1. Что значит «правильная архитектура» в этом контексте

Ключевые критерии:

1. Один источник правды для бизнес-логики и данных (домейн не размазан по трем UI).
2. Чёткое разделение слоёв:

   * доменная логика,
   * доступ к данным (API, кэш, БД),
   * презентация (web / mobile / что угодно ещё).
3. Максимальное переиспользование кода там, где это оправдано (типы, модели, доменные функции, API-клиент).
4. Независимое развитие клиентов (можно развивать мобилу, не ломая web, и наоборот).
5. Масштабируемость: можно добавить ещё один клиент (например, админское мобильное приложение) без архитектурного передела.

---

### 2. Базовый принцип: сначала нормальный backend, потом клиенты

Правильный порядок:

1. **Отделить домен и данные от UI**:

   * Доменные сущности (User, Order, Event и т.п.).
   * Бизнес-правила (валидация, статусы, переходы состояний).
   * Инварианты (что никогда не должно нарушаться).

2. **Сделать API-контракт между клиентами и бекендом**:

   * REST/GraphQL/gRPC — не принципиально, главное — стабильный контракт.
   * Типизированные модели (OpenAPI/Swagger, protobuf, схемы).
   * Версионирование API (v1/v2, feature flags для мобилы, если нужно).

3. **Вынести всё, что сейчас живёт в веб-клиенте, но относится к домену, в общий слой**:

   * маппинг DTO ⇄ domain,
   * подсчёты, агрегации, бизнес-валидация,
   * сервисы типа `PriceCalculator`, `ScheduleEngine` и т.д.

Результат: web и mobile — просто разные представления поверх одного и того же домена и одного и того же API.

---

### 3. Основные варианты реализации мобильной версии

По возрастанию «правильности» с точки зрения архитектуры и долгосрочной поддержки.

1. **Только адаптивный веб + PWA**

   * Что это: один фронтенд (React/Vue/etc.), просто хорошо сверстанный под мобильный экран, плюс PWA (иконка, offline кэш, немного нативного UX).
   * Плюсы: дешево, одна кодовая база фронта.
   * Минусы: ограниченный доступ к нативным возможностям, UX не как у настоящего приложения, зависимость от браузера.

2. **Обёртка через WebView (Cordova / Capacitor и т.п.)**

   * По сути тот же web, но в нативной оболочке.
   * Плюсы: быстрый запуск, тот же код UI, можно чуть-чуть использовать натив.
   * Минусы: производительность и UX страдают, архитектурно всё равно «толстый веб», а не нормальный мобильный клиент.

3. **Кросс-платформа: React Native / Flutter**

   * Это уже отдельный мобильный клиент, который:

     * использует общий доменный слой и API-клиент с вебом,
     * имеет собственный слой UI и навигации, заточенный под мобильный UX.
   * Плюсы: нормальное ощущение «родного» приложения, гибкость, возможность переиспользовать логику с web.
   * Минусы: нужна отдельная команда/экспертиза, два UI-слоя.

4. **Чистый native (Swift/Kotlin)**

   * Максимальный контроль, лучшая интеграция, но минимум прямого шаринга UI-кода.
   * Архитектурно похоже на (3), только ещё больше разделения.

Чаще всего для современного web-проекта оптимально: **Next.js веб + React Native / Expo мобила + общий доменный слой и API-клиент в монорепо**.

---

### 4. Типичная «правильная» архитектура в монорепо

Для стека типа: web (Next.js) + mobile (Expo / React Native):

```text
/apps
  /web         — веб-клиент (Next.js, SPA/SSR)
/mobile       — мобильный клиент (Expo / React Native)

/packages
  /domain      — чистый доменный слой (типизированные сущности, use-cases)
  /api-client  — HTTP/GraphQL-клиент, DTO, мапперы, хуки для данных
  /ui-core     — дизайн-система: токены, тема, headless-компоненты (логика без разметки)
  /utils       — общие утилиты (дата, форматирование, валидации и т.п.)
```

Принцип:

* `domain` и `api-client` не знают о React/React Native — только TypeScript + функции.
* `web` и `mobile` умеют:

  * подписываться на данные (React Query, TanStack Query и т.п.),
  * строить UI (HTML/CSS vs React Native Views),
  * применять навигацию своей платформы (Next.js маршруты vs React Navigation).
* Любая бизнес-логика: в `domain`. Любые вызовы API: в `api-client`.

---

### 5. Архитектура данных и взаимодействия

1. **DTO ↔ Domain**
   В API приходит DTO (сырой JSON). Его надо маппить на устойчивые доменные модели:

   * чтобы не ломать клиентов при мелких изменениях API;
   * чтобы в домене типы и инварианты были строже, чем в API.

2. **Версионирование и адаптация для мобилы**

   * Если мобильному клиенту нужны другие payload’ы (меньше/другие поля) — лучше делать:

     * либо отдельные эндпоинты (например, `/mobile/v1/...`),
     * либо BFF (Backend For Frontend), который агрегирует/упрощает данные.
   * Не городить костыли в мобиле вроде «мы берём 3 разных эндпоинта и вручную склеиваем их в один экран».

3. **Кэш и offline**

   * На мобиле почти всегда нужен локальный кеш: SQLite, MMKV, AsyncStorage.
   * Архитектурно это ещё один слой в `data`:

     * `RemoteSource` (API),
     * `LocalSource` (кеш/БД),
     * `Repository` (общий интерфейс для домена: достать сущность/список, синхронизировать).

---

### 6. Особенности именно мобильной архитектуры

На мобиле появляются требования, которых у веба часто нет:

1. **Offline-first / плохая сеть**

   * Репозитории → сначала читают из локального хранилища, потом синхронизируются с сервером.
   * Очередь операций: создать/обновить/удалить локально → отправить на сервер, как только сеть появится.

2. **Push-уведомления, deep links**

   * Нужен инфраструктурный слой для:

     * регистрации токенов устройства,
     * обработки пушей,
     * навигации по deep link (от пуша в конкретный экран с конкретным ID сущности).

3. **Навигация**

   * На мобиле — стеки, табы, модалки, nested навигация.
   * Логика навигации должна жить отдельно от домена (домен не знает, что есть TabNavigator).

4. **Состояние**

   * Общий подход — data-слой через React Query / Apollo / SWR + локальный стейт для UI (Zustand/Redux/MobX).
   * Доменные use-cases вызывают репозитории, а не напрямую `fetch`.

---

### 7. Как перейти от существующего веба к корректной мобильной архитектуре

Если веб уже есть:

1. **Инвентаризация**:

   * Какие доменные сценарии критичны для мобилы?
   * Какие есть уже API-эндпоинты и где логика спрятана сейчас (часто — прямо в React-компонентах).

2. **Выделение домена и еdata-слоя из web**:

   * Вынести бизнес-логику в общий `domain`.
   * Вынести HTTP-клиент и адаптеры в `api-client`.

3. **Переподключить web на новый общий слой**:

   * Веб переходит на `domain` + `api-client` вместо ручных `fetch` в компонентах.
   * После этого mobile автоматически получает тот же домен и те же API.

4. **Собрать мобильный UI**:

   * Поднять Expo / React Native-приложение.
   * Подключить те же `domain` и `api-client`.
   * Реализовать экраны, заточенные под мобильный UX (не пытаться «перерисовать сайт 1:1»).

5. **Добавить мобильные фичи**:

   * оффлайн, пуши, deep links, фоновые синки.

---

### 8. Типичные ошибки, которых стоит избегать

1. «Мобильная версия» = просто ещё один сайт на subdomain без адаптации архитектуры.
2. Дублирование бизнес-логики:

   * одни правила в web, другие — в mobile;
   * ручные проверки в компонентах вместо общего доменного слоя.
3. Прямые запросы к API из UI-компонентов без репозиториев и мапперов.
4. Отсутствие API-контракта и версионирования:

   * «мы поменяли поле в ответе, и у мобильных всё упало».
5. Попытка «переиспользовать» web-компоненты в React Native напрямую, вместо нормального разделения: общая логика + разные UI-обёртки.

---

Если кратко: правильная архитектура — это когда мобильное приложение рассматривается как равноправный клиент поверх общего домена и API, а не как побочный фронтенд с копипастой логики из веба.
Тогда речь уже не про отдельное мобильное приложение, а про **один веб-клиент, который прилично живёт на маленьком экране**. Тут другая архитектурная оптика.

Разберём по слоям.

---

## 1. Базовый принцип: один фронтенд, разные layout’ы

Правильный вариант в большинстве случаев:

* **1 кодовая база фронта (одни и те же маршруты, один домен, один React-приложение).**
* **UI слой спроектирован как responsive/mobile-first.**
* **Бизнес-логика и работа с данными вообще не зависят от устройства.**

Условно:

* `/domain`, `/api-client`, хуки `useXXX` — общие.
* Разница только в:

  * расположении блоков,
  * размере шрифтов/контролов,
  * типе навигации (бургер/таб-бар vs sidebar),
  * некоторых упрощениях интерфейса.

---

## 2. Как обычно устроена архитектура мобильной веб-версии

### 2.1. Разделение слоёв

На фронте всё равно нужны слои:

1. **Domain/data**

   * модели, use-cases, валидации, бизнес-правила;
   * запросы к API, кэш, нормализация данных.

2. **UI-ядро (design system + layout primitives)**

   * токены (spacing, шрифты, цвета);
   * базовые компоненты: `Button`, `Input`, `Card`, `Stack`, `Grid`, `Page`, `ScreenHeader` и т.п.;
   * они уже знают о breakpoints (xs/sm/md/lg).

3. **Feature-компоненты / страницы**

   * собирают из ядра интерфейсы экранов;
   * в них минимальная логика — вся тяжёлая работа уходит в хуки/use-cases.

> Разница между desktop и mobile должна прятаться прежде всего в **UI-ядре и layout-компонентах**, а не в бизнес-логике.

---

### 2.2. Responsive vs отдельные компоненты

Есть две стратегии, обе применимы, их обычно комбинируют.

#### Вариант A: Чистый responsive через CSS

* Один компонент страницы, внутри flex/grid-layout.
* Breakpoints по медиазапросам (`@media (max-width: …)`).
* Меняем:

  * направление колонок (`row` → `column`);
  * размеры (`font-size`, `padding`, `gap`);
  * видимость второстепенных блоков (`display: none`).

Плюсы:

* минимум дублирования кода;
* проще поддерживать.

Минусы:

* если мобильная версия сильно отличается по структуре (другая навигация, другие приоритеты), компонент превращается в монстра с кучей условий.

#### Вариант B: Разные компоненты для desktop и mobile, общие hooks

Примерно так:

```tsx
// общий хук
function useClientDayScreen() {
  const data = useClientDayQuery();
  const actions = useClientDayActions();
  return { data, actions };
}

// мобильный layout
function ClientDayMobile() {
  const { data, actions } = useClientDayScreen();
  return (
    <MobileScreen>
      {/* мобильное расположение блоков */}
    </MobileScreen>
  );
}

// десктопный layout
function ClientDayDesktop() {
  const { data, actions } = useClientDayScreen();
  return (
    <DesktopPage>
      {/* столбцы, таблицы, сайдбар и т.п. */}
    </DesktopPage>
  );
}
```

А дальше:

```tsx
export function ClientDayPage() {
  const isMobile = useBreakpoint('lt-md');
  return isMobile ? <ClientDayMobile /> : <ClientDayDesktop />;
}
```

Плюсы:

* UI строго разделён, нет CSS-адских условий;
* бизнес-логика остаётся единой в `useClientDayScreen`.

Минусы:

* больше файлов/компонентов;
* нужно следить, чтобы логика не поползла в Mobile/Desktop.

---

## 3. Навигация и структура для мобильного web

Что обычно меняют именно в веб-версии для мобильных:

1. **Навигация**

   * Sidebar на desktop → бургер-меню или нижний tab-bar на mobile.
   * Функционально — те же маршруты, но другие компоненты `Layout`.

2. **Иерархия экранов**

   * На desktop можно показывать «master–detail» (список + деталь рядом).
   * На mobile часто делают:

     * `/list` → список;
     * `/list/:id` → отдельная страница детали.
   * Архитектурно: разные layout’ы, один и тот же data-слой.

3. **Формы и большие таблицы**

   * Одна огромная форма на desktop → на mobile бьют на шаги (stepper / wizard).
   * Таблицы превращают в карточки (каждая строка — card).

Важно: **это всё UI-вопросы**, domain/data остаются теми же.

---

## 4. Perf и бандл: что важно именно для мобильного web

1. **Code splitting**

   * Не грузить на мобильный экран тяжёлые desktop-виджеты, если они там никогда не показываются.
   * Для больших подсистем: динамический импорт + ленивые компоненты.

2. **Mobile-first CSS**

   * Стили без медиазапросов — под мобильный.
   * Desktop-уточнения добавляются как `@media (min-width: …)`.
   * В результате мобильный бандл меньше (не нужно городить кучу override’ов).

3. **Минимум JS-логики для layout’а**

   * Layout лучше решать CSS’ом, а не расчётами ширин/высот в JS.
   * JS-ветвления оставлять для действительно разных компонент (см. вариант B).

---

## 5. Когда допустимо делать отдельный «m.» сайт

Иногда делают `m.example.com` или вообще отдельное приложение под мобильный web. Это оправдано, только если:

* мобильная версия по сути другой продукт (другие сценарии, сильно урезанный функционал);
* UX настолько отличается, что поддерживать один UI становится дороже, чем раздвоить;
* вы всё равно сохраняете:

  * общий backend,
  * общий доменный слой (как минимум на уровне API/контрактов и бизнес-правил).

Но это уже фактически два фронтенда. С точки зрения поддержки и архитектуры — это дорого.

---

## 6. Типовые анти-паттерны

Чего лучше не делать:

1. Вшивать условие `if (isMobile) ...` в бизнес-логику (валидаторы, use-cases, расчёты цен).
2. Дублировать запросы: на desktop один эндпоинт, на mobile другой, но логика одинаковая.
3. Держать «мобильную версию» как отдельный набор страниц, где всё копипастой из desktop и чуть-чуть переделано.
4. Навязывать домену понятия «мобильный/десктоп» — домен должен оперировать пользователями, ролями, сценариями, а не устройствами.

---

Если коротко по сути:

* **Мобильная веб-версия = тот же фронтенд, те же данные, тот же домен.**
* Различия — только в **UI-слое и layout-компонентах**, через responsive-стили и/или отдельные Mobile/Desktop-компоненты, поверх общих хуков и доменных use-cases.
Что лучше сделать, качественную мобильную веб версию, или, мобильное приложение? Учитывая трудощатраты и выхлоп

Если говорить честно и прагматично: в 80% случаев сначала выгоднее сделать **сильную мобильную веб-версию**, а нативное приложение имеет смысл только когда продукт уже «летит» и упирается в ограничения веба.

Разложу по критериям «трудозатраты → выхлоп».

---

## 1. Сравнение по ключевым параметрам

### Трудозатраты (разработка и поддержка)

**Мобильная веб-версия (responsive + PWA, если нужно)**

* Одна кодовая база фронта: web + mobile.
* Всё, что вы уже сделали для desktop, можно адаптировать layout’ом и компонентами.
* CI, деплой, логирование, мониторинг — всё одно и то же.
* Стоимость: условно ×1–1.5 к тому, что уже есть (в основном верстка, адаптация UX).

**Мобильное приложение (React Native / Flutter / native)**

* Появляется второй клиент:

  * отдельный UI-слой,
  * свои баги, свой релизный цикл,
  * отдельно тестировать, выкатывать, чинить.
* Плюс инфраструктура:

  * аккаунты в сторах, сборки, подписи, обновления,
  * политика стор, ревью, отклонения.
* Стоимость: минимум ×2 к фронтенду (два клиента), а по факту часто ×2.5–3, если делать нормально (офлайн, пуши, стабильный UX).

---

### UX и возможности

**Мобильный web**

* Можно сделать очень комфортный UX:

  * нормальные формы,
  * карточки вместо таблиц,
  * шаги вместо длинных форм,
  * быстрые загрузки, skeleton’ы, кеш.
* Ограничения:

  * слабый оффлайн,
  * пуши — только через PWA (ограниченно, не везде хорошо работает),
  * хуже доступ к железу (камера/сканер/файлы — можно, но не так удобно, как в native).

**Мобильное приложение**

* Сильные стороны:

  * стабильные push-уведомления,
  * оффлайн (локальная БД),
  * глубокая интеграция с камерой, файлами, сканерами и т.п.,
  * ощущение «настоящего» приложения, иконка на экране, автологин.
* Но: этот плюс ощущается только если:

  * пользователь реально пользуется приложением регулярно,
  * сценарии требуют оффлайна/пушей/железа.

---

### Охват и входной порог

**Мобильный web**

* Зашёл по ссылке — и ты внутри.
* Работает сразу на любых устройствах/браузерах.
* Для разовых/редких сценариев (посмотреть информацию, оплатить, подтвердить что-то) — идеален.

**Мобильное приложение**

* Нужно:

  * найти в сторе,
  * установить,
  * дождаться скачивания,
  * зайти/зарегистрироваться.
* Для пользователя это оправдано только если он **возвращается часто** и получает реальную выгоду от наличия приложения (скорость, оффлайн, пуши).

---

## 2. С точки зрения бизнеса и «выхлопа»

Честный расклад:

1. Если продукт на стадии:

   * MVP,
   * ранний рост,
   * ещё ищется product–market fit,
   * нет явного сигнала, что пользователи «живут» внутри сервиса каждый день/неделю,
     → **мобильное web + PWA** покрывает 90% задач при минимальной стоимости.

2. Нативное приложение оправдано, когда:

   * есть стабильный трафик и деньги,
   * есть регулярные сценарии:

     * каждый день открывают расписание,
     * чек-листы, смены, задачи,
     * пуши критичны (напоминания, статус, срочные изменения),
   * веб уже «выжат» по UX, но пользователям всё равно неудобно.

   Тогда приложение начинает давать:

   * рост удержания,
   * рост вовлечённости (пуши, оффлайн),
   * повышение LTV, снижение оттока.

Если этого нет — получаете вторую дорогую кодовую базу ради «круто, у нас есть приложение».

---

## 3. Что обычно делают в живых продуктах

Типичный путь:

1. Делают **качественный адаптивный web**:

   * норм навигация для мобильных,
   * формы и сценарии реально удобно прожимаются с телефона.

2. Добавляют **PWA**:

   * иконка на рабочем столе,
   * базовый оффлайн (кеш статики, последние данные),
   * частично пуши (там, где поддерживается).

3. Смотрят на метрики:

   * сколько людей заходят с мобилы,
   * как часто,
   * какие сценарии,
   * где они отваливаются.

4. Если видят, что:

   * есть устойчивое ядро пользователей с регулярными сценариями,
   * web объективно ограничивает UX,
   * оффлайн/пуши действительно нужны,
     → только тогда заходят в мобильное приложение.

---

## 4. Краткий вывод без украшений

* Если стоит вопрос «сейчас, при ограниченных ресурсах, что делать в первую очередь» — **делать качественную мобильную веб-версию (желательно mobile-first + PWA)**.
* Нативное мобильное приложение начинает окупаться только когда:

  * продукт стабилен,
  * есть повторяющееся использование,
  * web-ограничения реально мешают росту/опыту.

То есть по формуле «трудозатраты → выхлоп» порядок приоритетов такой:

1. Сильный мобильный web (responsive + продуманный UX)
2. PWA-слой поверх него
3. И только потом отдельное мобильное приложение, когда для этого есть жёсткие продуктовые причины, а не просто «хочется иконку в сторе».

Тогда дай подробный  план, как сделать аудит и собрать промпт на оценку состояние текущей веб версии приложения, чтобы собрать на её основе полноценную качественную удобную версию для мобильных устройств. Что учесть и что не забыть. 
Ниже план из двух частей:

1. как провести аудит текущей веб‑версии с прицелом на мобильный веб,
2. как на основе этого собрать сильный промпт для ИИ (ChatGPT/Claude/Copilot) для оценки и выдачи плана работ.

---

## 1. План аудита текущей веб‑версии

### Шаг 0. Зафиксировать цель мобильной веб‑версии

Что нужно прописать перед любым аудитом:

* Для кого мобильный веб (какие роли/персоны: админы, родители, преподаватели и т.д.).
* Какие задачи пользователь должен уметь закрывать **только с телефона**:

  * минимум: просмотр ключевой инфы,
  * желательно: создание/редактирование сущностей,
  * критично: какие действия нельзя потерять.
* Ограничения:

  * есть ли сценарии, которые вы *осознанно* оставляете только на desktop (аналитика, сложные таблицы, админка).

Это важно, иначе ИИ и вы будете «оценивать всё подряд», вместо приоритета по сценариям.

Результат: короткий текст 5–10 пунктов «Цели мобильной веб‑версии v1».

---

### Шаг 1. Краткая карта продукта и сценариев

Сделать инвентаризацию, но не по страницам, а по бизнес‑сценариям:

* Сценарии:

  * Регистрация / вход / восстановление пароля.
  * Просмотр главного дашборда / сводной инфы.
  * Основные CRUD‑операции (создать/редактировать/удалить).
  * Частые ежедневные действия (отметить статус, отметить посещаемость, зафиксировать событие и т.п.).
  * Поиск и фильтрация.
  * Оплата/счета (если есть).
* Для каждого сценария:

  * какие страницы/экраны участвуют,
  * какие данные критичны (без чего сценарий «не засчитан»),
  * насколько этот сценарий важен на телефоне (High/Medium/Low).

Результат: таблица/список сценариев с приоритетом. Потом это ляжет в промпт.

---

### Шаг 2. Аналитика текущего использования (если есть данные)

Нужно собрать хотя бы грубо:

* Доля мобильного трафика vs десктоп.
* Какие страницы чаще всего открывают с мобильных.
* Где на мобилках выше всего отказы / дроп воронки (логин, форма X, таблица Y).
* Среднее время на ключевых страницах.

Если аналитики нет — фиксируете это и сразу в промпт добавляете как ограничение, чтобы ИИ не делал вид, что опирается на данные.

Результат: 5–10 метрик/наблюдений о том, как сейчас реальный мобильный трафик живёт (или не живёт).

---

### Шаг 3. Инвентаризация UI и техн. базы под адаптив

Что собрать:

* Стек фронта: React/Next/Vue, есть ли уже дизайн‑система/компонентная библиотека.
* Есть ли:

  * собственные UI‑киты (Button, Input, Modal, Table, Card, Layout),
  * система брейкпоинтов (xs/sm/md/lg),
  * токены (spacing, шрифты, цвета).
* Есть ли уже какие‑то попытки адаптива:

  * медиа‑queries,
  * условный рендеринг `isMobile`,
  * отдельные layout’ы под мобилу.

Нужно честно ответить:

* у нас адаптив «налеплен поверх»,
* или есть внятная система layout/компонентов.

Результат: короткое описание тех. базы + список ключевых компонентов, которые станут «скелетом» мобильной версии (Layout, Header, Sidebar/Nav, Card, Table, Form).

---

### Шаг 4. Heuristic‑аудит ключевых сценариев на мобильных брейкпоинтах

Берёте 3–4 основных сценария **High‑приоритета** и прогоняете их на типичных ширинах: 360, 390, 414 px.

Для каждого сценария:

1. Навигация:

   * понятно ли, где пользователь находится;
   * как он попадает в сценарий с главной;
   * сколько шагов/кликов.

2. Видимость и иерархия:

   * заголовок экрана читаем?
   * самый важный элемент в зоне первого экрана?
   * нет ли горизонтального скролла, «обрезанных» блоков.

3. Кликабельные элементы:

   * размер кликабельной области ≥ ~44x44 px;
   * достаточно ли отступов между кнопками;
   * нет ли «микро‑ссылок», в которые невозможно попасть пальцем.

4. Формы:

   * поля нормально помещаются по ширине;
   * порядок полей логичен;
   * подсказки/валидация видны и читаемы;
   * нет ли «по два поля в строке», которые на мобиле становятся нечитабельными.

5. Таблицы / сложные данные:

   * таблица не превращается в горизонтальный ад;
   * можно ли прочитать ключевые значения без скролла вбок;
   * есть ли mobile‑представление (карточки).

6. Состояния:

   * загрузка (skeleton/spinner);
   * пустое состояние;
   * ошибки (сетевые, валидационные).

7. Жёсткие десктоп‑паттерны:

   * hover‑зависимые элементы;
   * сложные drag‑n‑drop;
   * resizable‑панели и т.п.

Результат: список проблем по каждому сценарию с грубой оценкой «Critical / Major / Minor» и комментариями.

---

### Шаг 5. Выявить «категории проблем», а не только частные баги

Систематизировать выводы:

Примеры категорий:

* Навигация:

  * нет мобильной структуры: слишком много уровней/ссылок в бургер‑меню;
  * не ясно, где «домой» или как вернуться назад.

* Layout:

  * все экраны наследуют десктопный layout, вместо мобильного single‑column;
  * слишком много контента на одном экране, нужны шаги/секции.

* Формы:

  * слишком длинные формы без разбивки;
  * нет автофокуса, нет масок, неудобные селекты.

* Таблицы:

  * нет карточного представления;
  * важные значения не акцентированы.

* Состояния:

  * почти нет пустых/ошибочных/загрузочных состояний, всё выглядит «сломано».

* Техническое:

  * тяжёлый бандл, долгая первая загрузка;
  * нет нормальных брейкпоинтов.

Результат: 5–10 категорий проблем с примером 1–2 экранов на каждую.

---

### Шаг 6. Приоритизация: что обязательно решать в v1 мобильного веба

На основе сценариев и категорий проблем:

* Выделить:

  * Must have (без этого мобильный веб бессмысленен),
  * Should have (важно, но можно отложить),
  * Nice to have.

* Привязать к сценариям:

  * «Чтобы сценарий X был решаем с телефона, нужно исправить A, B, C».

Результат: приоритизированный список задач для мобильной версии (на уровне UX/продукта, не только верстки).

---

### Шаг 7. Черновой концепт мобильного UX

На этом этапе формируете то, что важно потом вложить в промпт:

* Навигационная модель:

  * будет ли отдельный мобильный Layout,
  * бургер vs bottom‑nav,
  * какие разделы попадают в «нижнее меню» (самые частые сценарии).

* Принципы:

  * mobile‑first: сначала мобильный layout, потом расширяем под desktop;
  * 1 основной CTA на экране;
  * крупные и понятные заголовки и подсказки.

* Специфические решения:

  * таблицы → карточки;
  * формы → шаги/секции;
  * сложные фильтры → раскрывающиеся панели/bottom sheets.

Результат: текстовые принципы + пару схем/описаний. Это ляжет в промпт как «намерение» — чего вы хотите добиться от ИИ.

---

## 2. Как собрать промпт для ИИ на оценку текущего состояния

Задача промпта: не просто «покритикуй сайт», а:

1. сделать структурированный аудит именно с точки зрения мобильного web,
2. выдать план действий: от текущего состояния → к качественной мобильной версии.

Ниже — шаблон мастер‑промпта, который ты адаптируешь под свой проект.

---

### 2.1. Мастер‑промпт для общего аудита

```text
Ты выступаешь как Senior Product/UX дизайнер и фронтенд‑архитектор, специализирующийся на мобильной веб‑версии сложных B2B/B2C приложений.

КОНТЕКСТ ПРОДУКТА:
- Название продукта: {{название}}.
- Целевая аудитория и роли: {{кратко описать роли и их задачи}}.
- Основная ценность продукта: {{1–2 предложения, что пользователь получает}}.
- Стадия продукта: {{MVP / в проде / растущий продукт}}.

ЦЕЛЬ:
- Оценить текущую веб‑версию приложения (десктопно‑центричную) с точки зрения того,
  чтобы на её основе спроектировать качественную и удобную мобильную веб‑версию.
- Выявить архитектурные и UX‑проблемы, которые мешают использованию с телефона.
- Сформировать конкретный план работ по переходу к мобильному web (responsive/mobile‑first).

МАТЕРИАЛЫ:
- Стек фронта: {{React/Next/Vue/etc., наличие/отсутствие дизайн‑системы}}.
- Список ключевых сценариев и их приоритет: {{вставить список из Шага 1}}.
- Краткая аналитика мобильного трафика: {{доля мобилы, критичные страницы, если есть данные}}.
- Карта разделов/страниц: {{кратко перечислить разделы}}.
- Описание текущих проблем по мобильному использованию (если есть): {{bullet‑list}}.
- Ссылки/артефакты:
  - {{URL приложения / тестового окружения}}
  - {{описания экранов или скриншоты с пояснениями, если ИИ не может кликать по живому продукту}}

ОГРАНИЧЕНИЯ:
- Мы хотим **сохранить один фронтенд‑код, без отдельного "m." сайта**.
- Mobile app (нативное) пока не планируем, делаем ставку на качественный мобильный web.
- Ресурс на разработку: {{команда, примерные сроки, если релевантно}}.

ЗАДАЧА ДЛЯ ТЕБЯ:
Сделай аудит в несколько шагов:

1) Общая оценка текущей архитектуры фронта:
   - Насколько текущий подход (дизайн‑система, layout, брейкпоинты, работа с данными) пригоден
     для построения качественной мобильной версии.
   - Где ты видишь архитектурные риски и технический долг, мешающие mobile‑first.

2) UX‑оценка с точки зрения мобильного использования:
   Используя описания сценариев/экранов и ссылки/скриншоты, оцени:
   - Навигацию: как пользователь будет перемещаться между ключевыми сценариями с телефона.
   - Иерархию информации: что сейчас перегружено/распылено, что сложно читать с маленького экрана.
   - Формы: насколько они пригодны к вводу с телефона (длина, маски, валидация, ошибки).
   - Таблицы и сложные данные: что конкретно "ломается" на мобильном и требует другого представления.
   - Состояния загрузки/ошибок/пустоты: не будет ли пользователь думать, что "ничего не работает".
   - Размеры интерактивных элементов, отступы, типографика.

3) Категоризация проблем:
   - Объедини частные проблемы в 5–10 крупных категорий (Навигация, Layout, Формы, Таблицы, Состояния, Техническое).
   - Для каждой категории приведи 2–3 конкретных примера из текущего интерфейса.

4) План перехода к качественной мобильной веб‑версии:
   - Какие архитектурные изменения фронта ты рекомендуешь (например: ввести общий Layout‑слой, нормальные брейкпоинты, refactor таблиц в headless‑компоненты и т.д.).
   - Какие UX‑решения ты предлагаешь:
     - навигационная модель для мобилы (бургер, bottom‑nav, упрощённая структура),
     - подход к длинным формам,
     - подход к таблицам (карточки, сворачивание колонок, отдельные экраны деталей).
   - Разбей план на этапы:
     - Этап 1: быстрые правки (quick wins), которые сразу улучшат мобильный опыт.
     - Этап 2: структурные изменения (новый layout, переработка ключевых экранов).
     - Этап 3: улучшения и полировка (состояния, микровзаимодействия).

5) Риски и "не делать":
   - Чего нам лучше избегать (например, дублирование логики для mobile/desktop, отдельный код для m‑версии без общей дизайн‑системы и т.д.).

ФОРМАТ ОТВЕТА:
- Краткое резюме (3–5 предложений).
- Таблица/список категорий проблем → с примерами.
- Конкретный roadmap в виде списков задач по этапам (Этап 1/2/3).
- Дополнительные рекомендации по архитектуре фронта, если это критично для mobile‑first.
```

---

### 2.2. Локальный промпт для аудита отдельного экрана/флоу

Чтобы работать «вайб‑кодингом» по одному экрану, удобно иметь короткий промпт:

```text
Ты — Senior UX дизайнер, специализирующийся на мобильном web.

Вот контекст продукта: {{1–2 абзаца}}.
Вот сценарий, который реализует этот экран: {{описание сценария и его приоритет}}.
Вот описание экрана/флоу: {{текст + скриншоты/структура/JSX‑фрагменты}}.

Задача:
1) Оцени, насколько этот экран в текущем виде пригоден для использования на мобильном телефоне.
2) Выпиши:
   - что будет критично неудобно / сломано на мобильном;
   - что можно оставить как есть;
   - какие изменения layout/навигации/контента ты рекомендуешь.
3) Предложи целевую мобильную структуру экрана:
   - порядок блоков,
   - какие элементы скрыть / свернуть / вынести на отдельный шаг,
   - какой основной CTA и где его расположить.
4) Сформируй список конкретных задач для разработчика:
   - на уровне верстки/компонентов (что именно переписать),
   - на уровне UX (какие состояния добавить: пустые, ошибки, loading).

Формат ответа:
- Краткое резюме (до 5 предложений).
- Список проблем (Critical / Major / Minor).
- Описание целевой мобильной структуры экрана.
- Список задач (bullet‑list), готовый к переносу в таск‑трекер.
```

---

### 2.3. Что важно не забыть включить в промпт и аудит

* Ясный список **ключевых сценариев**, а не только страниц.
* Приоритеты: что обязательно должно работать с телефона, а что можно оставить слабым.
* Описание **текущего стека и дизайн‑системы**, чтобы ИИ не советовал «оторванные» решения.
* Ограничения по ресурсам/срокам (ИИ иначе будет городить идеалы без учёта реальности).
* Любые имеющиеся данные аналитики (даже грубые): доля мобилы, проблемные шаги.
* Скриншоты/описания именно в мобильной ширине (если можете — прикладывайте).
* Явное указание: **одна кодовая база фронта, без отдельного "m." сайта**.

Если всё выше собрать и превратить в материалы + промпт, ИИ (и ты сам) будет не просто «комментировать дизайн», а выдавать структурный план превращения текущей веб‑версии в полноценный мобильный web с понятным roadmap’ом.


