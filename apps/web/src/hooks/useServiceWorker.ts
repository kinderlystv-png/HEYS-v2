// filepath: apps/web/src/hooks/useServiceWorker.ts
// React hook –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ Service Worker —Å image optimization
// Performance Sprint Day 7

import { useState, useEffect, useCallback } from 'react';

import { serviceWorkerManager, type CacheStatus, type PerformanceMetrics } from '../utils/service-worker-manager';

interface ServiceWorkerState {
  isRegistered: boolean;
  isOnline: boolean;
  cacheStatus: CacheStatus | null;
  lastUpdate: Date | null;
  error: string | null;
}

interface ServiceWorkerActions {
  register: () => Promise<void>;
  unregister: () => Promise<void>;
  update: () => Promise<void>;
  preloadImages: (urls: string[]) => Promise<void>;
  clearImageCache: () => Promise<void>;
  sendMetrics: (metrics: PerformanceMetrics) => void;
  refreshCacheStatus: () => Promise<void>;
}

/**
 * Hook –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è Service Worker –∏ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å image optimization
 */
export function useServiceWorker(): ServiceWorkerState & ServiceWorkerActions {
  const [state, setState] = useState<ServiceWorkerState>({
    isRegistered: false,
    isOnline: navigator.onLine,
    cacheStatus: null,
    lastUpdate: null,
    error: null
  });

  // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è Service Worker
  const register = useCallback(async () => {
    try {
      setState(prev => ({ ...prev, error: null }));
      
      const registration = await serviceWorkerManager.register();
      
      setState(prev => ({
        ...prev,
        isRegistered: !!registration,
        lastUpdate: new Date()
      }));

      console.log('‚úÖ useServiceWorker: Service Worker registered');
    } catch (error) {
      console.error('‚ùå useServiceWorker: Registration failed:', error);
      setState(prev => ({
        ...prev,
        error: error instanceof Error ? error.message : 'Registration failed'
      }));
    }
  }, []);

  // –û—Ç–º–µ–Ω–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
  const unregister = useCallback(async () => {
    try {
      const success = await serviceWorkerManager.unregister();
      
      setState(prev => ({
        ...prev,
        isRegistered: !success,
        cacheStatus: null,
        lastUpdate: success ? new Date() : prev.lastUpdate
      }));

      console.log('üóëÔ∏è useServiceWorker: Service Worker unregistered');
    } catch (error) {
      console.error('‚ùå useServiceWorker: Unregistration failed:', error);
      setState(prev => ({
        ...prev,
        error: error instanceof Error ? error.message : 'Unregistration failed'
      }));
    }
  }, []);

  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ Service Worker
  const update = useCallback(async () => {
    try {
      await serviceWorkerManager.update();
      setState(prev => ({ ...prev, lastUpdate: new Date() }));
      console.log('üîÑ useServiceWorker: Service Worker updated');
    } catch (error) {
      console.error('‚ùå useServiceWorker: Update failed:', error);
      setState(prev => ({
        ...prev,
        error: error instanceof Error ? error.message : 'Update failed'
      }));
    }
  }, []);

  // –ü—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π —á–µ—Ä–µ–∑ Service Worker
  const preloadImages = useCallback(async (urls: string[]) => {
    if (!state.isRegistered) {
      console.warn('‚ö†Ô∏è useServiceWorker: Cannot preload - SW not registered');
      return;
    }

    try {
      await serviceWorkerManager.preloadResources(urls);
      console.log(`üöÄ useServiceWorker: Preloaded ${urls.length} images`);
    } catch (error) {
      console.error('‚ùå useServiceWorker: Image preload failed:', error);
      setState(prev => ({
        ...prev,
        error: error instanceof Error ? error.message : 'Preload failed'
      }));
    }
  }, [state.isRegistered]);

  // –û—á–∏—Å—Ç–∫–∞ –∫—ç—à–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
  const clearImageCache = useCallback(async () => {
    if (!state.isRegistered) {
      console.warn('‚ö†Ô∏è useServiceWorker: Cannot clear cache - SW not registered');
      return;
    }

    try {
      // –û—á–∏—â–∞–µ–º –∫—ç—à –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –ø–æ –ø–∞—Ç—Ç–µ—Ä–Ω–∞–º
      await serviceWorkerManager.clearCache('.jpg');
      await serviceWorkerManager.clearCache('.png');
      await serviceWorkerManager.clearCache('.webp');
      await serviceWorkerManager.clearCache('.avif');
      
      // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∫—ç—à–∞
      await refreshCacheStatus();
      
      console.log('üßπ useServiceWorker: Image cache cleared');
    } catch (error) {
      console.error('‚ùå useServiceWorker: Cache clear failed:', error);
      setState(prev => ({
        ...prev,
        error: error instanceof Error ? error.message : 'Cache clear failed'
      }));
    }
  }, [state.isRegistered]);

  // –û—Ç–ø—Ä–∞–≤–∫–∞ –º–µ—Ç—Ä–∏–∫ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
  const sendMetrics = useCallback((metrics: PerformanceMetrics) => {
    if (!state.isRegistered) {
      console.warn('‚ö†Ô∏è useServiceWorker: Cannot send metrics - SW not registered');
      return;
    }

    try {
      serviceWorkerManager.sendPerformanceMetrics(metrics);
      console.log('üìä useServiceWorker: Metrics sent:', metrics);
    } catch (error) {
      console.error('‚ùå useServiceWorker: Failed to send metrics:', error);
    }
  }, [state.isRegistered]);

  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∫—ç—à–∞
  const refreshCacheStatus = useCallback(async () => {
    if (!state.isRegistered) {
      return;
    }

    try {
      const cacheStatus = await serviceWorkerManager.getCacheStatus();
      setState(prev => ({ ...prev, cacheStatus }));
      console.log('üìä useServiceWorker: Cache status updated:', cacheStatus);
    } catch (error) {
      console.error('‚ùå useServiceWorker: Failed to get cache status:', error);
    }
  }, [state.isRegistered]);

  // –°–ª—É—à–∞–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è online/offline —Å—Ç–∞—Ç—É—Å–∞
  useEffect(() => {
    const handleOnline = () => {
      setState(prev => ({ ...prev, isOnline: true }));
      console.log('üåê useServiceWorker: Back online');
    };

    const handleOffline = () => {
      setState(prev => ({ ...prev, isOnline: false }));
      console.log('üì± useServiceWorker: Gone offline');
    };

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø—Ä–∏ –º–æ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞
  useEffect(() => {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —É–∂–µ –ª–∏ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω Service Worker
    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
      setState(prev => ({ ...prev, isRegistered: true }));
      
      // –°—Ä–∞–∑—É –ø–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç—É—Å –∫—ç—à–∞
      refreshCacheStatus();
    }
  }, [refreshCacheStatus]);

  // –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∫—ç—à–∞
  useEffect(() => {
    if (!state.isRegistered) return;

    const interval = setInterval(() => {
      refreshCacheStatus();
    }, 30000); // –ö–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥

    return () => clearInterval(interval);
  }, [state.isRegistered, refreshCacheStatus]);

  return {
    ...state,
    register,
    unregister,
    update,
    preloadImages,
    clearImageCache,
    sendMetrics,
    refreshCacheStatus
  };
}

/**
 * Hook –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏ –º–µ—Ç—Ä–∏–∫ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
 */
export function usePerformanceMetrics() {
  const { sendMetrics, isRegistered } = useServiceWorker();

  const sendImageLoadMetrics = useCallback((
    imageUrl: string,
    loadTime: number,
    fromCache: boolean,
    size?: number
  ) => {
    if (!isRegistered) return;

    const metrics: PerformanceMetrics = {
      bundleSize: size || 0,
      loadTime,
      imageLoadTime: loadTime,
      cacheHitRate: fromCache ? 1 : 0,
      errorCount: 0
    };

    sendMetrics(metrics);
    
    console.log(`üìä Performance: Image loaded - ${imageUrl} (${loadTime}ms, ${fromCache ? 'cache' : 'network'})`);
  }, [sendMetrics, isRegistered]);

  const sendErrorMetrics = useCallback((errorType: string, errorCount = 1) => {
    if (!isRegistered) return;

    const metrics: PerformanceMetrics = {
      bundleSize: 0,
      loadTime: 0,
      imageLoadTime: 0,
      cacheHitRate: 0,
      errorCount
    };

    sendMetrics(metrics);
    
    console.log(`üìä Performance: Error reported - ${errorType} (${errorCount})`);
  }, [sendMetrics, isRegistered]);

  return {
    sendImageLoadMetrics,
    sendErrorMetrics
  };
}

/**
 * Hook –¥–ª—è –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∏ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
 */
export function useImagePreloading() {
  const { preloadImages, isRegistered } = useServiceWorker();

  const preloadCriticalImages = useCallback(async (urls: string[]) => {
    if (!isRegistered || urls.length === 0) return;

    // –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
    const imageUrls = urls.filter(url => 
      /\.(jpg|jpeg|png|gif|webp|avif|svg)$/i.test(url)
    );

    if (imageUrls.length === 0) return;

    try {
      await preloadImages(imageUrls);
      console.log(`üöÄ Image Preloading: ${imageUrls.length} images queued for preload`);
    } catch (error) {
      console.error('‚ùå Image Preloading failed:', error);
    }
  }, [preloadImages, isRegistered]);

  const preloadImagesOnHover = useCallback(async (urls: string[]) => {
    // –ü—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∞ —Å –º–µ–Ω—å—à–∏–º –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º –¥–ª—è hover events
    if (!isRegistered) return;

    const imageUrls = urls.filter(url => 
      /\.(jpg|jpeg|png|gif|webp|avif)$/i.test(url)
    );

    if (imageUrls.length === 0) return;

    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ–±–æ–ª—å—à—É—é –∑–∞–¥–µ—Ä–∂–∫—É –¥–ª—è hover preloading
    setTimeout(() => {
      preloadImages(imageUrls).catch(console.error);
    }, 100);
  }, [preloadImages, isRegistered]);

  return {
    preloadCriticalImages,
    preloadImagesOnHover
  };
}
